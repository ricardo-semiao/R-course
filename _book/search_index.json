[["index.html", "R: Teoria e Aplicações Bem Vindo! Por que Este Livro? Organização do Livro Licensa Contato", " R: Teoria e Aplicações Ricardo Semião 03/2024 Bem Vindo! Este livro tem o objetivo de ensinar a liguagem R. O material tem duas especificidades principais: (i) é um livro para níveis diversos de experiência, é introdutório, mas expõe conceitos avançados e com profundidade; (ii) tem uma abordagem mista, primeiro focando na teoria, fundamentos, e functionamento da linguagem, mas depois apresentando temas aplicados. Abaixo explico a motivação para esse estilo, bem como para quem ele pode ser útil. Por que Este Livro? Existem diferentes estilos de aprendizagem, alguns preferem “aprender fazendo”, outros preferem “aprender estudando”. Este livro é, em sua maior parte, signatário do segundo. Porém, mesmo se esse não for seu estilo preferido, argumento que ele combina com o estudo de R. R é uma linguagem única, para o bem e para o mal: Ela contém muitas exeções, particularidades, e heranças de outros tempos. Elas são causas comuns de erros e dificuldades de compreensão. Aprender a regra, a teoria, o contexto geral, facilita muito aprender a lidar com exeções da maneira menos dolorosa possível. Ela contém ferramentas poderosas e incomuns. A especialização em estatísta motiva a existência de construtos nada óbvios, mas muito úteis. Existe uma variedade de estilos (funcionais, orientado ao objeto, metalinguísticos) igualmente importantes, mas difíceis de alcaçar sem um estudo mais teórico. Mas claro que o conhecimento aplicado também é quisto (deixemos o estudo teórico em si mesmo para os nerds da ciência da computação). Por isso, tento expor a parte teórica da maneira mais tranquila e enxuta possível, focando no essencial e deixando o extra como extra. Portanto, na segunda parte do livro, foco em aplicar o conhecimento recém adquirido para aprender a fazer as duas tarefas mais comums, presentes em basicamente todo projeto no R, a manipulação e visualização de dados. Por fim, na terceira parte, apresento aplicações variadas no estilo “livro de receitas”. Aqui, existe muita intersecção com uma extensa litaratura já existente, mas creio que vale muito a pena aprender como aplicar todo o arcabouço visto antes em alguns dos tipos de projetos mais comuns. Antes de seguir adiante, uma palava motivacional: as vezes uma pessoa passa mais tempo estudando um assunto do que deveria, e quanto mais fundo vai, mais difícil é parar de estudar. Esse é o meu caso, mas gostaria de ter companhia nessa situação (ninguém é de ferro). Foi com isso em mente que montei esse material, para dar a oportunidade do leitor fazer o mesmo, da forma mais eficiente possível. Espero que goste! Organização do Livro O livro é dividido em três partes: “R base”, “Ciência de Dados com o Tidyverse”, e “Aplicações Diversas”. As bases desse material estão descritas na seção @(refs), mas adianto o disclaimer: boa parte do conteúdo deste livro é uma curadoria, simplificação, e adaptação dos materiais abaixo (organizados por parte): Primeira parte - R Language Definition, e Advanced R, 2nd Edition. Segunda parte - R for Data Science, 2nd Edition, e tidyverse documentation. Terceira parte - R Cookbook, 2nd Edition, e Big Book of R. Introdução Para começar exponho alguns temas iniciais: A história da linguagem, suas características gerais, porque aprender R. A literatura sobre R, e as referências deste livro. O estilo e didática do livro. A instalação e explicação da interface do RStudio (de uma maneira bastante preguiçosa). Parte I - R base Os conceitos basilares do R costumam ser ensinados rapidamente, para dar prioridade na manipulação de dados e aplicações. Esse curso não fará isso, iremos passar com bastante calma por essa dimensão. Tanto porque existem menos tutoriais que fazem isso, mas principalmente, porque aprender sobre como o R funciona com detalhe gera uma série de benefícios: Permite entender códigos mais complexos; Permite aprender fontes comuns de erros e como evitá-las; Permite escrever códigos mais elegantes e principalmente mais eficiêntes; Facilitará a explicação dos conceitos que empoderam o tidyverse. Essa abordagem é algo como ter aulas formais de uma língua, em oposição a ensino para turismo. A utilidade dessa abordagem depende de seu objetivo, se ele é “conseguir aplicar rapidamente novos conhecimentos”, outros livros serão mais úteis. Parte II - Ciência de Dados com o Tidyverse Na segunda parte, iremos ver sobre manipulação e visualização de dados, porque ela é uma tarefa que será necessária para praticamente todas as aplicações do R. Existem vários frameworks diferentes para isso, o R base, o DataTable, e o tidyverse. Nesse curso escolho o tidyverse pois é um dos agregados de pacotes mais bem trabalhados, com uma sintaxe simples de entender, e que abrange todas as etapas da manipulação de dados. Ao fim, também trataremos rapidamente sobre um framework para lidar com datas e séries de tempo. Parte II - Aplicações Diversas A parte três apresenta várias aplicações específicas em R, sem detalhar muito a fundo todos seus detalhes nem explicar a teoria por trás, logo, mais com o objetivo de mostrar as possibilidades no R. Licensa Esse material, como um todo, está licenciado com a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Contato Meu nome é Ricardo Semião, sou mestrando em economia da FGV-EESP, e sou fã de R. Se tiver algum comentário sobre este material, por favor mande em meu email ricardo.semiao@outlook.com. Minhas outras redes são: Github. Linkedin. StackOverflow. Twitter. "],["introduction.html", "Capítulo 1 Introdução 1.1 História 1.2 Características da Linguagem, e “Porque R?” 1.3 Literatura sobre R 1.4 Estilo do Livro 1.5 Instalação, Interface, e Ferramentas", " Capítulo 1 Introdução 1.1 História R é “uma linguagem de programação e um ambiente para computação estatística e gráfica”. Ela criada em 1993 por Ross Ihaka e Robert Gentleman da Universdade de Auckland, Nova Zelândia, com o apoio de John Chambers da Bell Laboratories. Foi inspirada na linguagem S, e por ser sua sucessora (e pela inicial dos autores), recebeu o nome R. Não, infelizmente, não é R de “Ricardo”. “Ambiente” no sentido de que é uma linguagem de programação formal, um “sistema totalmente planejado e coerente”. Mas ainda assim, sendo especializada, com ferramentas poderosas e acessíveis para computação e vizualização de projetos estatísticos ou da ciência de dados. Ao mesmo tempo, é fácilmente incrementável, com centenas de extensões para as mais diversas áreas. Entidades associadas ao desenvolvimento da linguagem: O Comprehensive R Archive Network (CRAN) foi criado em 1997 por Kurt Hornik e Fritz Leisch para armazenar o código fonte, documentação, e pacotes do R. O R Core Team foi formado em 1997 para desenvolver a linguagem A linguagem como projeto e homepage oficial é o R Project. Também existe a homepage das versões em desenvolvimento do R. A R Foundation foi fundada em 2003 para guiar o R Project. O RStudio, agora Posit foi fundado para expandir a qualidade do projeto, lançando um ambiente de desenvolvimento integrado em 2011, e oferecendo soluções para empresas. O R Journal e R Blog. 1.2 Características da Linguagem, e “Porque R?” O R é uma linguagem bem específica. Abaixo cito algumas de suas características, e porque elas podem motivar seu estudo. R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para a maioria das máquinas/sistemas operacionais. Isso faz com que projetos no R sejam facilmente replicados por outros, e aumenta sua popularidade. R é uma linguagem popular, ficou na posição 21 no TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats do Twitter, no StackOverflow, no Posit Community, e pessoalmente. Um produto dessa popularidade é a quantidade massiva de extensões, para toda sorte de tarefa. Existem múltiplas abordagens para manipulação de dados, modelagem, e criação de vizualizações. Poderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps. Ferramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes no R para acompanhar sua pesquisa. Ocupa um espaço muito interessante na paisagem de softwares: É uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL. Mas é especializado, intepretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagems mais complexas/generalistas como C, e talvez Python. A especialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data-frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados. Algumas características mais técnicas: Sua sintaxe é similar à C e Python, mas sua semântica é a de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados. Além das funcionais, R tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e succintos. Não é seu forte, mas também conta com algumas ferramentas de programação orientada ao objeto, facilitando a vida do usuário. O R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar. Porém, nem tudo são flores. Muitas dessas características tem prós e contras, e a execução dessas ideias conta com heranças obsoletas e inconsistências. Neste livro, deixarei claro os pontos negativos mais importantes, e ensino a evitá-los. 1.3 Literatura sobre R A literatura base pode ser encontrada no CRAN. Ela é composta de, principalmente: O código fonte (R Core Team 2024b). O manual “R Language Definition” (R Core Team 2024d), que descreve a linguagem em si. O manual “R Internals” (R Core Team 2024c), que descreve as estruturas internas do R, e a fundação do código em C. A documentação de ajuda para o R base e as extensões padrões (R Core Team 2024e). A documentação de ajuda para as extensões externas. Nenhuma dessas é exatamente didática, mas existe uma vasta bibliografia de livros para R, tanto para ensinar a linguagem no geral, quanto para toda sorte de aplicações. Abaixo alguns exemplos mais recentes, divididos pela sua relação com cada parte deste livro. Bibliografia base da parte I: o livro “Advanced R” (segunda edição) (Hadley Wickham 2019), junto com “R Language Definition”. Outros livros introdutórios: “An Introduction to R” (R Core Team 2024a) (manual oficial). “Working with R” (Stephanie Locke 2017b). “An Introduction to R” (Longhow Lam 2010). Alguns livros complementares, que assumem uma abordagem “aprender fazendo”: “Hands on Programming with R” (Garrett Grolemund 2014). “A Student’s Guide to R” (Nicholas J. Horton, Daniel T. Kaplan, and Randall Pruim 2015). Bibliografia base da parte II: o livro “R for Data Science” (Hadley Wickham, Garrett Grolemund, and Mine Çetinkaya-Rundel 2024) e as documentações dos pacotes do tidyverse (“Tidyverse,” n.d.). Outros livros sobre manipulação e visualização de dados: “Data Manipulation in R” (Stephanie Locke 2017a). “ggplot2: Elegant Graphics for Data Analysis” (Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen 2010). “Data Wrangling Recipes in R” (Hilary Watt and Tristan Naidoo, n.d.). Alguns livros complementares, que assumem uma abordagem “aprender fazendo”: Introduction to Data Exploration and Analysis with R (Michael Mahoney 2019). “The R Primer”. Bibliografia base da parte III: o livro “R Cookbook” (segunda edição) (Hadley Wickham 2019), e o livro “Big Book of R” (Oscar Baruffa 2024). Existem muitos outros livros e tutoriais dedicados a aplicações específicas. Algumas listas (incompletas) podem ser encontradas no arquivo do CRAN. 1.4 Estilo do Livro Antes de prosseguir, quero expor de antemão o estilo e organização dos capítulos. Este livro tem muito a cobrir, e tem um andamento acelerado. Para facilitar ao máximo a vida do leitor, o estilo dos capítulos foi definido para ajudar a direcionar a atenção para o que é mais importante, e menos atenção para o extra. Abaixo apresento alguns dos construtos utilizados para tal. Pequenos excertos de código são apresentados na linha 1 + 1, e blocos de código como abaixo. x &lt;- 1 + 1 x*2 “Nome” do resultado Resultados importantes são expostos neste tipo de bloco. Note que nem todos os resultados serão simples de entender imediatamente, mas são expostos no momento em que é relevante para o estudo da linguagem. Palavras em negrito: normalmente indicam conceitos que serão definidos. Após sua apresentação, os conceitos costumam deixar de aparecer em negrito. Palavras em itálico costumam ser palavras com utilizadas com um significado específico no contexto relevante, mas não necessariamente “conceitos”. Em contrapartida, as vezes uso aspas para indicar uma palavra sendo utilizada pelo seu significado em português, e não como um conceito da programação. Porém, cuidado, as vezes aspas tem seu uso padrão, e itálico é usado para palavras em inglês. as vezes é importante apresentar um exemplo para esclarecer um conceito. Tendo a colocar exemplos apenas quando necessário, de modo que é importante entendê-los. Em contrapartida, não há muitos exemplos “complementares”. É natural que essa baixa frequência torne difícil a compreensão de alguns temas. Mas para isso existem os exercícios. Observação: observações deste tipo costumam ser sobre a organização do livro ou outros esclarecimentos menos importantes. Ao final de cada capítulo existe uma seção de “Complemento”. Nele, há: Uma recapitulação dos conceitos apresentados. Uma lista de exercícios, que pode, inclusive, apresentar novos conceitos/funções. Uma lista de funções apresentadas no capítulo. Uma seção de referências, inclusive com links para conceitos deixados de lado no capítulo, para o leitor que quiser ir além. 1.5 Instalação, Interface, e Ferramentas Antes de começar o aprendizado, é preciso instalar a linguagem (R), e se familizarizar com a interface do editor de código oficial (RStudio). Veja como instalar neste tutorial do curso “R Para Jornalistas”. PS: coincidentenmente, a maneira que jornalistas instalam o R serve para qualquer outra profissão também. Existêm vários tutoriais online explicando a interface, como o da Datacamp (veja até “How to Write R Scripts in RStudio”) e este no video “RStudio for the Total Beginner”. Além disso, existem três configurações mais comuns de serem alteradas: alterar onde os arquivos são salvos por padrão (figura 1, “browse”); impedir que os dados da última vez que você entrou no R sejam recarregados quando você voltar (figura 1, “workspace”); e alterar aparência (figura 2). Todas elas podem ser encontradas na tab Tools &gt; Global Options: Mais informações úteis sobre a interface podem ser encontradas na Seção “Navigating the Software” de (James Long and Paul Teetor 2019). Até o momento, eu fui preguiçoso e não trouxe esse material para o livro. Ainda assim, veja as referências com calma, não deixe confusões com o software atrapalharem seu aprendizado. Última coisa, eu juro. O R provê alguns comandos para procurar por ajuda. A função vignette() abre uma lista de artigos de ajuda das extensões do R. Adicionalmente, se você quer saber informações sobre uma função chamada “acaba_pelo_amor_de_deus”, os códigos abaixo abrem suas documentações de ajuda. Vejam mais sobre aqui, e aqui. ?acaba_pelo_amor_de_deus help(&quot;acaba_pelo_amor_de_deus&quot;) Agora sim, vamos começar. Boa sorte! References "],["r-base.html", "R Base", " R Base Bem vindo à primeira parte deste livro, onde estudaremos os conceitos na base do R. Partirei do zero absoluto, de modo que é possível que o leitor tenha algum nível de familiaridade com os temas, mas provavelmente, não na profundidade aqui abordada. Nessa parte mais “teórica”, é difícil de traçar o limite no nível de complexidade ideal. Por conta disso, muitos conceitos tiveram de ser introduzidos rapidamente. Mas não se assute, muitas vezes, meu objetivo maior é passar uma intuição geral de como o R funciona, e dar um primeiro contato com os temas mais complexos. Tento ao máximo deixar claro onde gastar seu cérebro e onde nem tanto. Meu foco é mostrar a lógica do R, a “sintaxe e semântica” da linguagem. A “gramática/vocabulário”, isto é, funções, truques, e aplicações específicas, serão ensinadas de passagem e via exercícios. Mas no final, a ideia é ter apresentado a maioria das funções commumente relevantes, construindo uma lista de referência para futuras consultas. Os capítulos dessa seção estão organizados da seguinte maneira: Capítulo 2: aqui aprenderemos o básico sobre a sintaxe do R. Como imputar números e texto, o que são expressões e variáveis, e como realizar operações básicas. No geral, um capítulo bastante simples. Capítulo 3: a organização de tipos de dados no R é elegantemente simples, incluindo complexidade através da existência de metadados. A principal conclusão será entender a relação entre os diferentes tipos, porque esse conhecimento torna mais fácil pensar como uma mesma operação é aplicada em cada tipo de dado. Capítulo 4: nessa altura do campeonato, capaz que você esteja cansado de ver apenas teoria, esse capítulo é o mais “gramatical” de todos. Aprenderemos o que é a operação de selecionar e alterar partes de uma variável. Aqui, já fica claro o benefício de entender a organização dos tipos de dados. Capítulo 5: aprenderemos a controlar o fluxo de um programa, isto é, como fazer um programa tomar decisões e repetir operações. Aprenderemos também a lidar com erros e avisos. Capítulo 6: em oposição ao capítulo 3, agora é hora de dar atenção aos sentimentos do R. Estávamos utilizando-as, mas não explicamos o que são as funções. Esse é o capítulo mais desafiador, mas boa parte da dificuldade pode ser deixada de lado, com perdas reduzidas ao leitor. Capítulo 7: aqui, aprenderemos sobre os paradigmas/estilos de programação funcional, orientada ao objeto, e meta, especificamente sobre sua abordagem no R. A programação funcional é uma ferramenta com ligação direta nos projetos de ciência de dados; Entender o básico de POO no R é importante para entender o uso de funções[^Se chutou “objetos”, chutou errado.]; Metaprogramação é um assunto útil em si mesmo, mas especialmente importante para entender as bases do tidyverse na segunda parte do livro. Capítulo 8: por fim, temos algum outros tópicos úteis, mas não essenciais para o seguimento do livro. Aqui, aprenderemos sobre algumas ferramentas de melhoria de vida que o RStudio provê, e alguns temas avançados sobre gerenciamento de memória, performance, e organização. Recapitulado: não só em cada capítulo, mas cada parte deste livro, existe uma seção para retomar os conteúdos, especialmente o que será mais útil para a próxima parte. "],["syntax-variables.html", "Capítulo 2 Sintaxe e Variáveis 2.1 Sintaxe 2.2 Variáveis 2.3 Operadores Complemento", " Capítulo 2 Sintaxe e Variáveis 2.1 Sintaxe Em termos simplistas, um script é um arquivo de texto com instruções a serem executadas por um computador que antes traduzirá o arquivo para linguagem de máquina. Um script é um texto instrucional como qualquer outro, escrito em um tipo de linguagem especial, “de programação”, ou “código”, mas é um texto. Pode similar à receita de bolo de cenoura da minha vó, ou o roteiro da peça escolar onde interpretei, com maestria, a árvore #3. Como em qualquer linguagem, temos um vocabulário à disposição, um conjunto de palavras (ou tokens) existentes, organizadas em categorias como substantivos, adjetivos, etc. Nós combinamos as palavras em frases (ou statements) para descrever as instruções. Por fim, organizamos o texto em parágrafos (ou blocks), conjuntos de frases que devem ser lidas juntas, para definir a estrutura e facilitar o entendimento do texto. Ok, a receita da minha vó não tinha parágrafos, a metáfora não é perfeita, paciência. A seguir, vamos descrever com mais calma esses conceitos de tokens, statements, blocks, e script. 2.1.1 Palavras Vocabulário Quais palavras, tokens, temos disponíveis na linguagem R? Dados, que podem ser strings (palavras literais), números, valores booleanos (valores binários de verdadeiro ou falso), entre outros. Também podemos ter “coleções” desses dados (ex: vários números em uma “lista”). Variáveis, nomes associados à objetos. No futuro, veremos que podemos associar muito mais do que apenas dados à variáveis, por isso a nomenclatura mais geral “objetos”. Mais precisamente, a “palava” em si é o nome. Funções, que definem operações à serem realizadas usando variáveis/valores. Operadores, símbolos como + e &gt;, são um tipo de função especial, que apresentam uma sintaxe mais enxuta. Em termos simplificados, dados e variáveis são nossos substantivos (variáveis são “nomes próprios”), enquanto funções são nossos verbos. Como escrevemos essas palavras em um texto em R? Strings: utilize aspas duplas \" ou aspas simples': &quot;Hello World!&quot;, &#39;Hello World!&#39;1. Números: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01. Valores booleanos: escreva as palavras especiais TRUE e FALSE. Coleções: calma, tudo em seu tempo. Funções: escreva o nome da função, e os arumentos que ela receberá entre parênteses sum(1, 1). Não se preocupe muito com elas por agora. Operadores: são imputados como 1 + 1. Parênteses podem ser utilizados em operações matemáticas: (1+1)/2. Comentários: texto que não será avaliado como código. Use o símbolo #, que torna tudo após delena mesma linha, um comentário. Observação: nos exemplos deste livro, um comentário no formato #&gt; ... indica o resultado esperado da expressão que o precede. 2.1.2 Frases Como dito, as frases no R serão combinações de tokens. Qualquer combinação. cada linha do código abaixo é uma frase: 1 1 + 1 a &lt;- 1 #define a variável &quot;a&quot; com valor &quot;1&quot; a #pede o valor da variável &quot;a&quot; sum(1, 1) sum(1, 1) + a Algumas frases são apenas o nome de uma variável (a), algumas são a chamada de uma função sum(1, 1){r}, algumas são algo mais geral. Cada uma dessas tem um nome especial. Vou ensiná-los abaixo, mas não se preocupe demais, suas definições formais serão expostas no tema de “Metaprogramming”. “Frases” da linguagem Existem três tipos de “frases” que compõe a linguagem R, names, calls, e expressions (respectivamente). Note que expressions são algo mais geral, podendo ser compostas de names e calls. O uso de aspas em “frases” é proposital. Eu menti um pouco aqui, mas irei corrigir esse resultado na seção de variáveis. Com essa definição, parece que o que estamos chamando de “frase” é sinônimo de “expressão”. Veremos no tema de “Metaprogramming” que isso não é 100% preciso. E quanto a um código como 1 +? Bom, esse código não é sintáticamente correto. Tendemos a não chamar isso de frase/statement, mas formalmente, ele pode ser uma expression. 2.1.3 Parágrafos Como delimitamos frases em parágrafos? Por padrão, uma expressão acaba na quebra de linha. Se a expressão terminar inacabada (como no exemplo 1 +), o R ignora a quebra de linha, e tenta completar a expressão com a linha seguinte. Um ponto e vírgula pode ser usado para delimitar uma expressão explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável. Várias frases podem ser agregadas em grupos ou blocks usando chaves {}. Um grupo de frases é avaliado apenas após seu fim. Observação: a partir de aqui, “frase” ou “statement” se refere a uma unidade ou a um grupo de frases. veja alguns exemplos de frases. note que frases podem ser compostas de outras frases: a #é uma frase 1 #é uma frase {1} #é a mesma frase que a anterior 1 + 1 #é uma frase, uma operação &quot;+&quot; sobre dois &quot;1&quot;&#39;s { 1 + 1 2 + 2 } #é uma frase, compostas por duas frases (meio estranho, eu sei) 1 + 1; 2 + 2 #é a mesma frase que a anterior Nada disso deve fazer muito sentido em termos práticos ainda, tudo bem, apenas é preciso já ir se acostumando com a estrutura geral de um programa. Antes de avançar, vou mentir um pouco e dar uma definição simplificada de função, mas que será melhor detalhada no capítulo 6. Função É uma expressão, que depende de variáveis, associada à um nome. Utilizar esse nome, indicando os valores das variáveis envolvidas (entre parênteses ()), avalia a expressão, retornando seu resultado. liar &lt;- {x + y} #meramente ilustrativo, a sintaxe real é mais complexa liar(x = 1, y = 2) #&gt; 3 liar(1, 2) #equivalente à expressão anterior Com essa definição em mente, vale incluir funções na nossa analogia de parágrafos, também as usamos para organizar o texto. No capítulo 6, veremos que operadores são funções como qualquer outra, que apenas apresentam uma sintaxe diferente. 2.2 Variáveis Um dos tipos de palavras, as variáveis, merecem mais da nossa atenção. Mas não é para elas se acharem demais, dados e funções terão seus próprios capítulos. 2.2.1 Definindo Variáveis Para definir variáveis, escrevemos seu nome, = ou &lt;-, e a frase que definirá seu valor: x = 1 + 1, x &lt;- 1 + 1. Variáveis, nomes, e objetos Ao rodar algo como x &lt;- 1, o valor 1 é salvo na memória do computador, e associado ao nome x. Note que temos três parcelas: A informação salva na memória do computador (no exemplo, 1), é chamada de objeto. O nome associado à esse objeto (no exemplo, x), é chamado de, bom, nome. Variável se refere ao conjunto nome-objeto. No capítulo 3, veremos que “objeto” é algo muito geral. Especialmente, names, calls, e expressions também são objetos. O leitor ainda não deve ter o contexto suficiente pra essa frase fazer tanto sentido, e tudo bem. Ainda assim, já vale para eu me retratar: Objetos da linguagem Existem três tipos de objtos que compõe a linguagem R, names, calls, e expressions (respectivamente). Note que expressions são algo mais geral, podendo ser compostas de names e calls. No futuro, ficará claro que termos tão poucos objetos compondo a linguagem é algo distintivo do R, e gerará resultados que, eu pelo menos, considero muito bonitos (e gosto não se discute). 2.2.2 Copy on Modify Com base no que aprendeu, como pensaríamos em y &lt;- x? A resposta não é nada óbvia. Note que temos duas opções: y pode ser um novo nome, associado ao mesmo objeto, mesma posição na memória do computador, que x. y pode ser um novo nome, associado a um novo objeto, nova posição na memória do computador, que x, mas carregando a mesma informação. No R, a realidade é a primeira opção. Porém, se y for alterado, x não é (e vice versa). O que ocorre é que uma nova posição na memória é criada para armazenar (ao menos parte da) informação do novo y. Esse processo, de apenas “separar”/“copiar” objetos quando modificados, é chamado de copy-on-modify. Diferentes tipos de dados terão diferentes relações com esse processo, mas vou poupá-los disso. O importante é saber que não temos os objetos são copiados quando modificados, alterar y não altera x e vice versa, independente da complexidade do objeto. Em outras palavras: Copy-on-modify No R, um mesmo objeto pode ter ser referenciado a mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças. Existem duas exeções: objetos com apenas uma referência, e ambientes2. Esses são alterados “na hora”/“no lugar”, ou modify-in-place. 2.2.3 Outras Características Note que = e &lt;- são muito similares, mas = serve para mais coisas que somente definição de variáveis, como indicar argumentos em uma função. Portanto, &lt;- funciona como “definidor” em mais contextos, e é uma má prática utilizar = como definidor. Ambos podem definir várias variáveis de uma vez: x = y = 3, x &lt;- y &lt;- 3, x = y &lt;- 3. Existe um terceiro operador &lt;&lt;-, que será discutido no capítulo 6. 2.2.4 Regras de Nomenclatura Nem toda combinação de caracteres pode ser um nome de variável. As principais regras são: Nomes podem conter letras, números, “.” e “_“. São “case-sensitive”. Podem começar apenas com letras ou “.”. Não podem ser palavras reservadas como “TRUE”. Nomes não sintáticos podem ser definidos, se escritos usando crases (backticks) “`”: `_x` &lt;- 1. Você provavelmente encontrará isso ao importar dados que não foram criados no R. Em muitos momentos, o R converte nomes não sintáticos utilizando a função make.names(). Você aprenderá sobre ela nos exercícios. É muito importante estar atento à esse comportamento, uma vez que é causa comum de erros. Você verá que isso é um tema comum: o R tenta fácilitar muitas tarefas, fazendo as coisas por você. Isso por um lado é o que o torna fácil de sair trabalhando, mas sempre é causa de inconsistências. 2.3 Operadores A princípio, deixaria os detalhes sobre operadores para os exercícios, mas fiquei com medo deles se sentirem excluídos. Abaixo estão os operadores relevantes para o momento, suas descições, e seu uso. Clique nos links dos operadores para abrir suas páginas de ajuda. Categoria Operador Descrição Uso aritmétrica + soma num + num aritmétrica - subtração num - num aritmétrica * multiplicação num * num aritmétrica / divisão num / num aritmétrica \\^ exponenciação num ^ num aritmétrica %% divisão inteira num %% num aritmétrica %/% resto da divisão num %/% num comparação == igual x == y comparação != diferente x != y comparação &lt; menor que num &lt; num comparação &gt; maior que num &gt; num comparação &gt;= maior igual num &gt;= num comparação &lt;= menor igual num &lt;= num lógica ! “não” lógico ! logi lógica &amp; “e” lógico logi &amp; logi lógica &amp;#124; “ou” lógico logi &amp;#124; logi Observação: na coluna de “Uso”, “logi” se refere a qualquer valor que se comporte como um valor booleano, “num” a qualquer valor que se comporte como número, “expr” à qualquer expressão, e “x”/“y” à valores mais genéricos, ou à nomes de variáveis. Agora vou apresentar a ordem de precedência da aplicação dos operadores. Associatividade se refere à como são resolvidos “empates”, “direita pra esquerda” significa que o operador mais à direita é analisado antes. Tudo ficará mais claro no exemplo seguinte. Operador Descição Associatividade (), {} agrupadores direita pra esquerda ::, ::: acessar namespaces (*) direita pra esquerda $, @ extração de components/slots (*) esquerda pra direita [, [[ indexação (*) esquerda pra direita ^ exponenciação esquerda pra direita -, + (unary) mais e menos unários esquerda pra direita : sequências (*) esquerda pra direita %%, %/%, %xyz%, |&gt; operadores especiais (*) esquerda pra direita *, / multiplicação, divisão esquerda pra direita +, - (binary) adição, subtração esquerda pra direita &gt;, &gt;=, &lt;, &lt;=, ==, != comparações esquerda pra direita ! “não” lógico esquerda pra direita &amp;, &amp;&amp; “e” lógico (*) esquerda pra direita |, || “ou” lógico (*) esquerda pra direita ~ (unary and binary) fórmula (*) esquerda pra direita -&gt;, -&gt;&gt; definição pra direita (*) esquerda pra direita &lt;- ,&lt;&lt;- definição pra esquerda (*) direita pra esquerda = (definidor) definição pra esquerda direita pra esquerda Observação: linhas com um “(*)” apresentam operadores que ainda não foram apresentados. para deixar mais claro, na expressão (3+6)/(1+2)/5^4 o seguinte ocorre: () são analizados primeiro, porque tem precedência (estão acima na tabela). Como é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9. ^ é analizado a seguir, logo, 5^4 vira 625. / é analizado a seguir. Como é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048. Complemento Recapitulando Sintaxe Neste capítulo, vimos a estrutura geral de um programa: As palavras do programa, podem ser valores, variáveis, ou funções. Valores serão o tema do próximo capítulo. Vimos como imputar cada tipo de palavra. As frases do programa são combinações de palavras. Podem ser delimitadas por quebras de linha ou chaves. Podem ser organizadas em parágrafos vias chaves, ou “nomeadas” via funções. Inclusive, vimos que uma função, de modo simplista, é uma expressão, que depende de variáveis, associada à um nome. Scripts são sequências de frases. Variáveis Também demos uma atenção extra ao conceito de variável, nome, e objeto: Variáveis são nomes associados à informações na memória do computador, os objetos. Aprendemos os operadores que definem variáveis = e &lt;-, e porque &lt;- é preferível. Vimos características como x &lt;- y &lt;- 3 e as regras de nomenclatura. Bem como alguns conceitos mais técnicos e avançados: A dinâmica da memória no R é pautada pelo conceito de copy-on-modify. No R, um mesmo objeto pode ter ser referenciado a mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças. As exeções são objetos com apenas uma referência, e ambientes, que usam modify-in-place. O conceito de objeto é muito geral. Inclusive, a prória linguagem R é composta por (apenas) três tipos de objetos: names, calls, e expressions. Expressions são algo mais geral, podendo ser compostas de names e calls. Operadores Por fim, apresentamos os operadores básicos, seu uso, e ordem de preferência. Também vimos que operadores são funções, apenas com sintaxe diferente. Exercícios Obsservação: os exercícios usam variáveis de mesmo nome. Lembre-se de limpar as definições de variáveis após completar um exercício, rodando a frase rm(list = ls()). Variáveis Explique a diferença entre 1 e cada uma das variáveis abaixo. 1 a &lt;- 1 b &lt;- a c &lt;- a + 1 d &lt;- b e &lt;- 1 Foi comentado que objetos mais complexos têm comportamentos diferentes com relação ao processo de definição , mas todos seguem uma característica geral. Com base nisso, o que você espera que ocorra com b após a terceira linha do código abaixo? a &lt;- 1 b &lt;- list(a, a) a &lt;- a + 1 Obsservação: você verá a função list() no próximo capítulo, mas saiba que ela cria uma lista, uma coleção, dos elementos que a são passados como argumentos. Leia a página de ajuda da função make.names() para aprender as regras completas de definição de nomes, sobre como o R converte nomes não sintáticos. Preveja qual será o resultado das chamadas abaixo. make.names(&quot;&quot;) make.names(&quot;@&quot;) make.names(&quot;TRUE&quot;) make.names(&quot;`TRUE`&quot;) Operadores Parta de um número qualquer x, por exemplo, x &lt;- 5. Use os ensinados operadores para criar: Uma frase que retorne TRUE se x for múltiplo de 2. Uma frase que retonre TRUE se x não for múltiplo nem de 3, nem de 5. Uma frase que retonre TRUE se a parte inteira da divisão de x por 4 é igual a 2, ou se seu quadrado for maior ou igual à 10. Liste a ordem das ações executadas no cálculo da expressão abaixo: x &lt;- FALSE | !5.2 %% 2*7*4 - -3 &lt;= 100 &amp; TRUE Dicionário de Funções Abaixo segue a lista de funções vistas neste capítulo. Categoria Função Descrição Uso aritmétrica + soma num + num aritmétrica - subtração num - num aritmétrica * multiplicação num * num aritmétrica / divisão num / num aritmétrica \\^ exponenciação num ^ num aritmétrica %% divisão inteira num %% num aritmétrica %/% resto da divisão num %/% num comparação == igual x == y comparação != diferente x != y comparação &lt; menor que num &lt; num comparação &gt; maior que num &gt; num comparação &gt;= maior igual num &gt;= num comparação &lt;= menor igual num &lt;= num lógica ! “não” lógico ! logi lógica &amp; “e” lógico logi &amp; logi lógica &amp;#124; “ou” lógico logi &amp;#124; logi agrupadores { agrupador chaves { expr } agrupadores ( agrupador parênteses ( expr ) definidores &lt;-, -&gt; definidores x &lt;- expr, x -&gt; expr definidores = definidores x = expr outros rm() limpa objetos do ambiente rm(x) nomes make.names() NA NA ajuda help(), ? procurar ajuda na documentação help(x), ?x ajuda vignette() procurar vignettes vignette(x) Referências Alguns caracteres de texto são especiais, e precisam ser precedidos por uma barra. Mais sobre isso no capítulo @strings-factors.↩︎ Tratados no capítulo 6↩︎ "],["data-attributes.html", "Capítulo 3 Tipos de Dados e Atributos 3.1 Famílias 3.2 Vetores atômicos 3.3 Listas 3.4 Atributos Complemento", " Capítulo 3 Tipos de Dados e Atributos Aviso: este capítulo está em construção. O que segue abaixo é apenas um rascunho. 3.1 Famílias 3.1.1 Tipos de Dados No R, os tipos de dados são organizados em “famílias”. Antes de entrar nesse mérito, abaixo estão os tipos mais importantes: Logicals são os dados booleanos, podem ser TRUE ou FALSE. Podem ser abreviados para T e F Characters são os dados de texto (strings) Intergers são números inteiros, e são escritos com um L no fim Doubles são os números decimais, podem ser decimais 1.245, científicos 1.23e4, ou hexadecimais 0xadfe Valores especiais: Inf, -Inf, e NaN (“not a number”, usado em indefinições matemáticas) Existem outros dois tipos menos utilizados: raw são os dados binários; complex são os números complexos Todos os tipos explicados assumem um valor especial, o “valor desconhecido”: NA (non aplicable) A maioria das operações envolvendo NA`s retorna um NA: 1 + NA #&gt; NA Como NA é um valor desconhecido, checar se um NA é igual ao outro não faz sentido NA == NA #&gt; NA Por trás dos panos, existe um NA diferente para cada tipo de vetor atômico (NA_interger_, etc.) Um dado “sozinho” (3) é chamado de scalar. Mas o R também apresenta “coleções” de dados: (1, 2, 3, 4, 5) 3.1.1.1 Definição Uma coleção de escalares de um mesmo tipo é um atomic vector Um escalar é uma “coleção de tamanho um”, e portanto, todo escalar é um vetor atômico Logo, não existe um objeto “sem estar em um vetor”. x &lt;- &quot;a&quot; é um vetor atômico de tamanho 1 Obs: os componentes de uma coleção são chamados de “elementos” 3.1.1.2 Atenção Vetores atômicos não aceitam elementos de tipos diferentes, e não aceitam elementos que tamanho maior que um Porém, o R permite coleções com essas características, como (1, &quot;a&quot;, (1, 2, 3), TRUE, 1) 3.1.1.3 Definição Uma coleção de vetores é um generic vector, ou, mais comumente, uma list Um vetor genérico/lista também é um vetor, de modo que listas podem conter outras listas A lista tem seu próprio tipo, list Resumindo, temos: Os seis tipos “básicos” / tipos de escalares Vetores atômicos, coleções de escalares de mesmo tipo Mesmo quando seu tamanho é unitário (os próprios escalares) Vetores genéricos, coleções de vetores Não precisam ser atômicos, podem ter elementos de tipos diferentes Não precisam ser de escalares, podem ter elementos de tamanhos diferentes de 1 Consequentemente, podem conter qualquer vetor, atômico ou genérico (si mesmos) Apresentam seu próprio tipo, list 3.1.2 Famílias Como disse, os tipos de dados no R são organizados em “famílias”. Existem duas: Vector abrange os vetores atômicos e as listas. É a família dos dados “propriamente ditos” Node é a família de “dados internos” do R (funções, ambientes, etc.) Adicionalmente, NULL, um objeto especial, não é um vetor, mas pode ser entendido como a “ausência de dado”/“vetor de tamanho zero” A seguir, vamos entrar em detalhe sobre vetores 3.2 Vetores atômicos Você já deveria saber que x &lt;- 3 está criando um vetor atômico. Mas e para criar vetores atômicos mais longos? A função c() combina (daí o nome) vetores em um mais longo. Ela serve com atômicos ou genéricos, mas por enquanto, vamos usá-la com atômicos: c(TRUE, FALSE) c(1L) c(1, 3.5, 1.23e4) c(&quot;a&quot;, &quot;2&quot;) Quando usada com vetores atômicos, c() coage os inputs a escalares do mesmo tipo, resultando em um outro atomic vector Example 3.1 3.2.0.1 Exemplo Qual o resultado do exemplo abaixo? c(c(1, 2), c(3, 4)) E abaixo? c(1, 2, &quot;a&quot;, &quot;b&quot;) Existe uma ordem de prioridade: se houver um character, tudo vira character, fora isso, tudo vira double, depois, interger, e por fim, logical Podemos testar o tipo de um vetor com is.logical(), is.integer(), is.double(), e is.character() Existem funções extras is.vector(), is.atomic(), e is.numeric(), mas são imprevisíveis Podemos transformar o tipo de um vetor com as.logical(), as.integer(), as.double(), ou as.character() As mesmas contrapartes existem aqui typeof() retorna o tipo de um vetor, length() retorna seu tamanho Obs: funções que pedem argumentos de um mesmo tipo normalmente os coagem caso eles não o sejam 3.3 Listas Características gerais: O typeof() de uma list é &quot;list&quot; Diferentemente dos V.A., uma lista de tamanho 1 não é um escalar list() cria uma nova lista is.list() e as.list() unlist() transforma uma lista em um vetor atômico, mas de maneiras inesperadas No futuro, trataremos das funções do pacote purrr No tema de “Gerenciamento de memória” falaremos sobre como, por trás dos panos, listas são apenas referências aos objetos, de modo que list(x, x) ocupa bem menos que o dobro do espaço de list(x) c() também pode combinar listas Example 3.2 3.3.0.1 Exemplo Analize, desenhe, e compare os objetos abaixo: l1 &lt;- list(list(1), list(2)) l2 &lt;- list(list(1), 1) l3 &lt;- list(list(1,2,3), c(1,2,3)) l4 &lt;- c(list(1), list(2)) l5 &lt;- c(list(1), 2) l6 &lt;- c(list(1,2,3), c(1,2,3)) Basicamente, a função list() cria “caixinhas” para cada um de seus argumentos, enquanto a função c() não o faz 3.4 Atributos Os vetores podem carregar mais informações do que apenas os valores de seus elementos, eles podem carregar metadados (dados que informam algo sobre os elementos), os atributos Existem três atributos principais: names, um vetor character, que nomeia cada elemento dim (diminutivo de dimentions), um vetor interger, que reorganiza vetores em matrizes e arrays (“matrizes multidimensionais”) class, um vetor character, que indica um “tipo 2.0”, alterando o comportamento dos vetores Atributos não afetam a estrutura básica (tipo) dos objetos, mas podem afetar seu comportamento 3.4.1 Nomes Podemos nomear um vetor de várias formas: x &lt;- c(a = 1, b = 2, c = 3) names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x &lt;- setNames(x, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) (ou a função set_names() do pacote purrr) Podemos remover nomes com: x &lt;- unname(x) Example 3.3 Que valor/objeto colocaríamos em y para remover os nomes? names(x) &lt;- y É fácil ver como a estrutura básica fica inalterada. Tente transpor essa ideia para os outros atributos mais complexos 3.4.2 Dimensões Um vetor com o atributo dimensão é um vetor que deve ser interpretado como organizado em linhas e colunas (para matrizes): m1 &lt;- c(T, F, T, T, F, T) dim(m1) &lt;- c(2, 3) #ou matrix(c(T, F, T, T, F, T), nrow = 2, ncol = 3) Ou como organizado em matrizes multidimensionais (para arrays): a1 &lt;- c() dim(a1) &lt;- c(2, 3, 2) #ou array(1:12, c(2, 3, 2)) Também podemos ter matrizes e arrays feitas com listas: m2 &lt;- list(1, 2, &quot;c&quot;, list(&quot;d&quot;), TRUE, c(3, 4)) dim(m2) &lt;- c(2, 3) Example 3.4 Que lista complexa! Como poderíamos desenhá-la? E sua versão de matriz? Uma matriz ou array sempre é atômica? O que aconteceria com os outros elementos se eu alterasse o primeiro elemento de m1 para &quot;a&quot;? E se eu fizesse o mesmo com m2? Como atributos não alteram a estrutura básica, as funções para vetores tem generalizações para matrizes e arrays: Vector Matrix Array names() rownames(), colnames() dimnames() length() nrow(), ncol() dim() c() rbind(), cbind() abind() is.vector is.matrix() is.array() Note que adicionar dimensões gerou algumas possibilidades Um tamanho e um atributo de nome para cada dimensão Maneiras diferentes de combinar objetos Operação de transposição (com t() e aperm()) 3.4.3 Classes Outro attributo importante é class, que permite a criação de vetores diferenciados, criados em cima dos tipos básicos Esse atributo empodera o sistema de programação orientada ao objeto S3. Nele, funções agem diferentemente a depender da classe do argumento que estão recebendo. Abaixo vão algumas: factor são intergers para dados categóricos Date, POSIXct, e difftime são doubles para datas data.frame e tibble são lists para bases de dados Existem outros como ts para séries de tempo, uma classe para cada tipo de vetor estudado, entre outros Obs: existem outras famílias de classes 3.4.3.1 Factors Factors tem o atribuito class como &quot;factor&quot;, e um atributo levels que define os valores/categorias possíveis factor(c(&quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;), levels = c(&quot;m&quot;, &quot;f&quot;, &quot;o&quot;)) #&gt; [1] m f f m #&gt; Levels: m f o Cuidado, factors comumente geram erros Também existem os ordered factors, onde indicamos uma ordem para os levels, e costumam ser usados em funções de modelagem e visualização (vide ordered()) 3.4.3.2 Datas Dates: são um double com o atributo class &quot;Date&quot;. Por trás dos panos são o número de dias desde 01/01/1970. Para criar: as.Date(&quot;1970-02-01&quot;) Date-times: são um double com o atributo class &quot;POSIXct&quot;. Por trás dos panos são o número de segundos desde 01/01/1970. Para criar: as.POSIXct(&quot;2018-08-01 22:00&quot;, tz = &quot;UTC&quot;) Durations: são um double com o atributo class &quot;difftime&quot;, que conta a distância entre duas datas. Têm o atributo &quot;units&quot; que indica como o valor deve ser interpretado. Para criar: as.difftime(1, units = &quot;weeks&quot;) 3.4.3.3 Data frames Um data frame é uma representação de uma tabela de dados. Basicamente, uma lista nomeada de vetores, normalmente atômicos, de mesmo tamanho: list(coluna1 = c(1, 2, 3), coluna2 = c(&quot;c&quot;, &quot;b&quot;, &quot;d&quot;), coluna3 = c(TRUE, FALSE, NA)) Como sempre, ter isso em mente ajudará muito a transpor o conhecimento sobre listas para data frames Data frames têm os atributos names (nomes das “colunas”), row.names (nomes das “linhas”), e a class &quot;data.frame&quot; Funções úteis: São criados com data.frame() Um data frame tem nrow() linhas E ncol()/length() colunas Também existem as funções “is” e “as” Uma coluna de um data frame pode também ser uma matriz/array (se o número de linhas coincidir), ou uma lista (se o número de itens coincidir) Um Tibble é um sucessor data frame trazido pelo pacote “tibble” (parte do tidyverse). Tibbles são “preguiçosos e grosseiros: fazem menos e reclamam mais”: Tem a class c(&quot;data.frame&quot;, &quot;tbl_df&quot;) Não geram vetores maiores a partir de vetores menores (data.frame(x = 1:4, y = 1:2)) Não mudam nomes não sintáticos Não aceitam rownames (“metadata is data”) Um subset de um tibble sempre é um tibble Não tem matching parcial nos nomes de colunas Permitem referenciar colunas na hora da criação (tibble(x = 1:4, y = 2*x)) Tem uma melhor visualização no console Algumas funções relacionadas à atributos: atributes(x) retorna uma lista com os atributos de x attr(x, &quot;attr&quot;) retorna o valor do atributo &quot;attr&quot; Atributos importantes têm funções próprias (names(), dim(), class()) unclass(x) remove a classe de x, retornando-o ao tipo base structure(x, &quot;attr&quot; = valor) adiciona os atributos especificados em x str(x) retorna uma visualização da estrutura de x Obs: a maior parte pode ser usada para definir/alterar valores de atributos Complemento Recapitulando Como imputar valores “Definições” de expressão, função, e objeto (&amp; nome) Criação de variáveis Operadores de definição = e &lt;- Regras de nomenclatura Definição. Metadados que alteram algo sobre o vetor names alter visualização e como referenciar os elementos dim altera como o elemento é organizado, e é aplicável à todo tipo de vetor typeof()/class() e funções “as” e “is” (extra: is.na()) Funções criadoras c(), list(), matrix(), array(), factor(), odered(), data.frame(), tibble(), unlist() Funções combinadoras c(), cbind(), rbind(), e pacote “abind” Funções sobre dim: dim(), length(), nrow(), ncol() Funções sobre names: names, colnames(), rownames(), dimnames(), setNames()/set_names(), unname() Funções sobre atributes: str(), atributes(), attr(), structure(), unclass() Outras: t(), I() (extra: stringsAsFactors = FALSE) Exercícios Example 3.5 3.4.3.4 Vetores atômicos Porque 1 == &quot;1&quot; é verdadeiro? Porque -1 &lt; FALSE é verdadeiro? Porque &quot;one&quot; &lt; 2 é falso? Agora com operações aritmétricas. 1 + “2” funciona? e TRUE + 1? Qual é a regra? Porque o NA padrão é um vetor lógico? Pense no resultado de c(FALSE, NA_character_) Trabalhamos exemplos envolvendo c() e listas. Busque na página de ajuda ?c() pela ordem completa de coerção O que &quot;a&quot; == c(&quot;a&quot;) retorna? e identical(&quot;a&quot;, c(&quot;a&quot;))? Estude o argumento recursive = TRUE de c(). O que ele faria em: c(list(1), list(2)), c(list(1), 2), c(list(1,2,3), c(1,2,3))? Example 3.6 3.4.3.5 Listas Estude os objetos abaixo. Desenhe-os: l1 &lt;- list(1:3, &quot;a&quot;, c(T, F, T), c(2.3, 5.9)) l2 &lt;- list(list(list(1))) l3 &lt;- list(list(1, 2), c(3, 4)) l4 &lt;- c(list(1, 2), c(3, 4)) Faça o mesmo, agora estudando o tipo e classe: l5 &lt;- list(1:4, &quot;a&quot;, list(&quot;a&quot;), matrix(1,2,3)) l6 &lt;- l5; dim(l6) &lt;- c(2,2) l7 &lt;- as.data.frame(l6) Example 3.7 3.4.3.6 Atributos Como setNames() funciona? Como unname() funciona? Olhe o código fonte O que dim() retorna quando applicado a um vetor unidimensional? Quando NROW() e NCOL() podem ser úteis? Como você descreveria os objetos abaixo? Qual a diferença entre eles e 1:5? x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Example 3.8 3.4.3.7 Vetores atômicos S3 O que faz a função table()? Que objeto retorna? Qual seu tipo? Quais seus atributos? Como sua dimensão muda ao adicionar variáveis para tabular? O que acontece com um factor ao alterar seus níveis? f1 &lt;- factor(letters) levels(f1) &lt;- rev(levels(f1)) O que o código abaixo faz? como f2 e f3 diferem de f1? f2 &lt;- rev(factor(letters)) f3 &lt;- factor(letters, levels = rev(letters)) Example 3.9 3.4.3.8 Listas S3 Pode haver um data frame com zero linhas? E zero colunas? O que ocorre se você definir rownames não únicos? Se df é um data frame, o que é t(df)? Porque? E t(t(df))? O que as.matrix() faz quando aplicada a um data frame com colunas de tipos diferentes? Como isso difere de usar data.matrix()? Example 3.10 3.4.3.9 Listas S3 Estude o objeto abaixo. As colunas tem a mesma length? Existe alguma outra medida de dimensão igual? Isso faz sentido? x &lt;- data.frame(a = 1:2) x$b &lt;- c(matrix(1, 1, 1), matrix(2, 1, 1)) x$c &lt;- list(matrix(1, 1, 1), matrix(2, 1, 1)) x$d &lt;- data.frame(c1 = factor(c(&quot;a&quot;, &quot;b&quot;))) Dicionário de Funções Referências "],["subsetting.html", "Capítulo 4 Subsetting 4.1 Operador [ 4.2 Operador [[ 4.3 Atribuição 4.4 Aplicações", " Capítulo 4 Subsetting 4.1 Operador [ 4.2 Operador [[ 4.3 Atribuição 4.4 Aplicações "],["control-conditions.html", "Capítulo 5 Control Flow e Condições 5.1 Introdução 5.2 Choices 5.3 Loops 5.4 Condições", " Capítulo 5 Control Flow e Condições 5.1 Introdução 5.2 Choices 5.3 Loops 5.4 Condições "],["functions-environments.html", "Capítulo 6 Funções e Ambientes 6.1 Fundamentos 6.2 Ambientes 6.3 Scoping e Evaluation 6.4 OOP: Funções Genéricas 6.5 Conceitos Adicionais", " Capítulo 6 Funções e Ambientes 6.1 Fundamentos 6.2 Ambientes 6.3 Scoping e Evaluation 6.4 OOP: Funções Genéricas 6.5 Conceitos Adicionais "],["paradigms.html", "Capítulo 7 Paradigmas de Programação 7.1 Programação Funcional 7.2 Programação Orientada ao Objeto 7.3 Metaprogramação", " Capítulo 7 Paradigmas de Programação 7.1 Programação Funcional 7.2 Programação Orientada ao Objeto 7.3 Metaprogramação "],["other-topics.html", "Capítulo 8 Outros Tópicos 8.1 Projetos, Github, e Addins 8.2 Debbuging 8.3 Gerenciamento de Memória 8.4 Performance 8.5 Organização de Código e Boas Práticas", " Capítulo 8 Outros Tópicos 8.1 Projetos, Github, e Addins 8.2 Debbuging 8.3 Gerenciamento de Memória 8.4 Performance 8.5 Organização de Código e Boas Práticas (tidyverse style), lintr, e o outro pacote lá "],["recapitulando-2.html", "Recapitulando", " Recapitulando "],["ciência-de-dados-com-o-tidyverse.html", "Ciência de Dados com o Tidyverse", " Ciência de Dados com o Tidyverse "],["ciência-de-dados-e-importação.html", "Capítulo 9 Ciência de Dados e Importação", " Capítulo 9 Ciência de Dados e Importação "],["manipulação-de-dados.html", "Capítulo 10 Manipulação de Dados", " Capítulo 10 Manipulação de Dados "],["strings-factors.html", "Capítulo 11 Manipulação de Strings e Factors", " Capítulo 11 Manipulação de Strings e Factors "],["visualização-gráfica.html", "Capítulo 12 Visualização Gráfica", " Capítulo 12 Visualização Gráfica "],["programação-funcional-1.html", "Capítulo 13 Programação Funcional", " Capítulo 13 Programação Funcional "],["manipulação-de-séries-de-tempo.html", "Capítulo 14 Manipulação de Séries de Tempo", " Capítulo 14 Manipulação de Séries de Tempo "],["aplicações-diversas.html", "Aplicações Diversas", " Aplicações Diversas Descição da seção "],["dicionário-de-funções-2.html", "Dicionário de funções", " Dicionário de funções "],["referências-2.html", "Referências", " Referências "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
