[["index.html", "R: Teoria e Aplicações Bem Vindo! Por que Este Livro? Organização do Livro Licensa Contato", " R: Teoria e Aplicações Ricardo Semião 03/2024 Bem Vindo! Este livro tem o objetivo de ensinar a liguagem R. O material tem duas especificidades principais: (i) é um livro para níveis diversos de experiência, é introdutório, mas expõe conceitos avançados e com profundidade; (ii) tem uma abordagem mista, primeiro focando na teoria, fundamentos, e functionamento da linguagem, mas depois apresentando temas aplicados. Abaixo explico a motivação para esse estilo, bem como para quem ele pode ser útil. Por que Este Livro? Existem diferentes estilos de aprendizagem, alguns preferem “aprender fazendo”, outros preferem “aprender estudando”. Este livro é, em sua maior parte, signatário do segundo. Porém, mesmo se esse não for seu estilo preferido, argumento que ele combina com o estudo de R. R é uma linguagem única, para o bem e para o mal: Ela contém muitas exeções, particularidades, e heranças de outros tempos. Elas são causas comuns de erros e dificuldades de compreensão. Aprender a regra, a teoria, o contexto geral, facilita muito aprender a lidar com exeções da maneira menos dolorosa possível. Ela contém ferramentas poderosas e incomuns. A especialização em estatísta motiva a existência de construtos nada óbvios, mas muito úteis. Existe uma variedade de estilos (funcionais, orientado ao objeto, metalinguísticos) igualmente importantes, mas difíceis de alcaçar sem um estudo mais teórico. Mas claro que o conhecimento aplicado também é quisto (deixemos o estudo teórico em si mesmo para os nerds da ciência da computação). Por isso, tento expor a parte teórica da maneira mais tranquila e enxuta possível, focando no essencial e deixando o extra como extra. Portanto, na segunda parte do livro, foco em aplicar o conhecimento recém adquirido para aprender a fazer as duas tarefas mais comums, presentes em basicamente todo projeto no R, a manipulação e visualização de dados. Mas sempre relacionando com os conceitos “teóricos” da ciência de dados. Por fim, na terceira parte, apresento aplicações variadas no estilo “livro de receitas”. Aqui, existe muita intersecção com uma extensa litaratura já existente, mas creio que vale muito a pena aprender como aplicar todo o arcabouço visto antes em alguns dos tipos de projetos mais comuns. Antes de seguir adiante, uma palava motivacional: as vezes uma pessoa passa mais tempo estudando um assunto do que deveria, e quanto mais fundo vai, mais difícil é parar de estudar. Esse é o meu caso, mas gostaria de ter companhia nessa situação (ninguém é de ferro). Foi com isso em mente que montei esse material, para dar a oportunidade do leitor fazer o mesmo, da forma mais eficiente possível. Espero que goste! Organização do Livro O livro é dividido em três partes: “R base”, “Ciência de Dados com o Tidyverse”, e “Aplicações Diversas”. As bases desse material estão descritas na seção @(refs), mas adianto o disclaimer: boa parte do conteúdo deste livro é uma curadoria, simplificação, e adaptação dos materiais abaixo (organizados por parte): Primeira parte - R Language Definition, e Advanced R, 2nd Edition. Segunda parte - R for Data Science, 2nd Edition, e tidyverse documentation. Terceira parte - R Cookbook, 2nd Edition, e Big Book of R. Introdução Para começar exponho alguns temas iniciais: A história da linguagem, suas características gerais, porque aprender R. A literatura sobre R, e as referências deste livro. O estilo e didática do livro. A instalação e explicação da interface do RStudio (de uma maneira bastante preguiçosa). Parte I - R base Os conceitos basilares do R costumam ser ensinados rapidamente, para dar prioridade na manipulação de dados e aplicações. Esse curso não fará isso, iremos passar com bastante calma por essa dimensão, tanto porque existem menos tutoriais que fazem isso, mas principalmente, porque aprender sobre como o R funciona com detalhe gera uma série de benefícios: Permite entender códigos mais complexos. Permite aprender fontes comuns de erros e como evitá-las. Permite escrever códigos mais elegantes e principalmente mais eficiêntes. Facilitará a explicação dos conceitos que empoderam o tidyverse. Essa abordagem é algo como ter aulas formais de uma língua, em oposição a ensino para turismo. A utilidade dessa abordagem depende de seu objetivo, se ele é “conseguir aplicar rapidamente novos conhecimentos”, outros livros serão mais úteis. Parte II - Ciência de Dados com o Tidyverse Na segunda parte, iremos aplicar os conhecimentos obtidos e a linguagem desenvolvida para aprender sobre duas das tarefas mais comuns em aplicações do R, manipulação e visualização de dados. Porém, ensino esses conceitas com base na “teoria” por trás de projetos de ciência de dados. Vamos executar essas tarefas no R usando o framework tidyverse. Escolhi falar sobre ele, em oposição à usar o R base, ou outro framework, porque ele é um dos agregados de pacotes mais bem trabalhados, com uma sintaxe simples de entender, e que abrange todas as etapas da manipulação de dados. Especialmente, os conceitos expostos na parte I farão com que sua compreensão seja muito mais simples. Parte II - Aplicações Diversas A parte três mostra como aplicar os conhecimentos adquiridos nas outras duas partes, em temas comuns. Já existe uma literatura extensa com objetivos similares, portanto, foco em temas mais centrais, e/ou que tenham um alto ganho de serem abordados com os frameworks e linguagem desenvolvida neste livro. Os temas são: problemas comuns da probabilidade e estatística, exploração de dados, modelagem de regressão, e modelagem de machine learning. Ao fim, listo referências para otras aplicações de possível interesse. Licensa Esse material, como um todo, está licenciado com a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Contato Meu nome é Ricardo Semião, sou mestrando em economia da FGV-EESP, e sou fã de R. Se tiver algum comentário sobre este material, por favor mande em meu email ricardo.semiao@outlook.com. Minhas outras redes são: Github. Linkedin. StackOverflow. Twitter. "],["introduction.html", "Capítulo 1 Introdução 1.1 História 1.2 Características da Linguagem, e “Porque R?” 1.3 Literatura sobre R 1.4 Estilo do Livro 1.5 Instalação, Interface, e Ferramentas", " Capítulo 1 Introdução 1.1 História R é “uma linguagem de programação e um ambiente para computação estatística e gráfica”. Ela criada em 1993 por Ross Ihaka e Robert Gentleman da Universdade de Auckland, Nova Zelândia, com o apoio de John Chambers da Bell Laboratories. Foi inspirada na linguagem S, e por ser sua sucessora (e pela inicial dos autores), recebeu o nome R. Não, infelizmente, não é R de “Ricardo”. “Ambiente” no sentido de que é uma linguagem de programação formal, um “sistema totalmente planejado e coerente”. Mas ainda assim, sendo especializada, com ferramentas poderosas e acessíveis para computação e vizualização de projetos estatísticos ou da ciência de dados. Ao mesmo tempo, é fácilmente incrementável, com centenas de extensões para as mais diversas áreas. Entidades associadas ao desenvolvimento da linguagem: O Comprehensive R Archive Network (CRAN) foi criado em 1997 por Kurt Hornik e Fritz Leisch para armazenar o código fonte, documentação, e pacotes do R. O R Core Team foi formado em 1997 para desenvolver a linguagem A linguagem como projeto e homepage oficial é o R Project. Também existe a homepage das versões em desenvolvimento do R. A R Foundation foi fundada em 2003 para guiar o R Project. O RStudio, agora Posit foi fundado para expandir a qualidade do projeto, lançando um ambiente de desenvolvimento integrado em 2011, e oferecendo soluções para empresas. O R Journal e R Blog. 1.2 Características da Linguagem, e “Porque R?” O R é uma linguagem bem específica. Abaixo cito algumas de suas características, e porque elas podem motivar seu estudo. R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para a maioria das máquinas/sistemas operacionais. Isso faz com que projetos no R sejam facilmente replicados por outros, e aumenta sua popularidade. R é uma linguagem popular, ficou na posição 21 no TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats do Twitter, no StackOverflow, no Posit Community, e pessoalmente. Um produto dessa popularidade é a quantidade massiva de extensões, para toda sorte de tarefa. Existem múltiplas abordagens para manipulação de dados, modelagem, e criação de vizualizações. Poderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps. Ferramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes no R para acompanhar sua pesquisa. Ocupa um espaço muito interessante na paisagem de softwares: É uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL. Mas é especializado, intepretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagems mais complexas/generalistas como C, e talvez Python. A especialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data-frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados. Algumas características mais técnicas: Sua sintaxe é similar à C e Python, mas sua semântica é a de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados. Além das funcionais, R tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e succintos. Não é seu forte, mas também conta com algumas ferramentas de programação orientada ao objeto, facilitando a vida do usuário. O R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar. Porém, nem tudo são flores. Muitas dessas características tem prós e contras, e a execução dessas ideias conta com heranças obsoletas e inconsistências. Neste livro, deixarei claro os pontos negativos mais importantes, e ensino a evitá-los. 1.3 Literatura sobre R A literatura base pode ser encontrada no CRAN. Ela é composta de, principalmente: O código fonte (R Core Team 2024c). O manual “R Language Definition” (R Core Team 2024e), que descreve a linguagem em si. O manual “R Internals” (R Core Team 2024d), que descreve as estruturas internas do R, e a fundação do código em C. A documentação de ajuda para o R base e as extensões padrões (R Core Team 2024f). A documentação de ajuda para as extensões externas (R Core Team 2024b). Nenhuma dessas é exatamente didática, mas existe uma vasta bibliografia de livros para R, tanto para ensinar a linguagem no geral, quanto para toda sorte de aplicações. Abaixo alguns exemplos mais recentes, divididos pela sua relação com cada parte deste livro. Bibliografia base da parte I: o livro “Advanced R” (segunda edição) (Hadley Wickham 2019), junto com “R Language Definition”. Outros livros introdutórios: “An Introduction to R” (R Core Team 2024a) (manual oficial). “Working with R” (Stephanie Locke 2017b). “An Introduction to R” (Longhow Lam 2010). Livro complementar, com abordagem “aprender fazendo”: “Hands on Programming with R” (Garrett Grolemund 2014) Bibliografia base da parte II: o livro “R for Data Science” (Hadley Wickham 2024) e as documentações dos pacotes do tidyverse (“Tidyverse,” n.d.). Outros livros sobre manipulação e visualização de dados: “Data Manipulation in R” (Stephanie Locke 2017a). “ggplot2: Elegant Graphics for Data Analysis” (Hadley Wickham 2010). “Data Wrangling Recipes in R” (Hilary Watt, n.d.). Livro complementar, com abordagem “aprender fazendo”: “Introduction to Data Exploration and Analysis with R” (Michael Mahoney 2019). Bibliografia base da parte III: o livro “R Cookbook” (segunda edição) (Hadley Wickham 2019), e o livro “Big Book of R” (Oscar Baruffa 2024). Existem muitos outros livros e tutoriais dedicados a aplicações específicas. Algumas listas (incompletas) podem ser encontradas no arquivo do CRAN. 1.4 Estilo do Livro Antes de prosseguir, quero expor de antemão o estilo e organização dos capítulos. Este livro tem muito a cobrir, e tem um andamento acelerado. Para facilitar ao máximo a vida do leitor, o estilo dos capítulos foi definido para ajudar a direcionar a atenção para o que é mais importante, e menos atenção para o extra. Abaixo apresento alguns dos construtos utilizados para tal. Pequenos excertos de código são apresentados na linha 1 + 1, e blocos de código como abaixo. x &lt;- 1 + 1 x*2 “Nome” do resultado Resultados importantes são expostos neste tipo de bloco. Note que nem todos os resultados serão simples de entender imediatamente, mas são expostos no momento em que é relevante para o estudo da linguagem. Palavras em negrito: normalmente indicam conceitos que serão definidos. Após sua apresentação, os conceitos costumam deixar de aparecer em negrito. Palavras em itálico costumam ser palavras com utilizadas com um significado específico no contexto relevante, mas não necessariamente “conceitos”. Em contrapartida, as vezes uso aspas para indicar uma palavra sendo utilizada pelo seu significado em português, e não como um conceito da programação. Porém, cuidado, as vezes aspas tem seu uso padrão, e itálico é usado para palavras em inglês. as vezes é importante apresentar um exemplo para esclarecer um conceito. Tendo a colocar exemplos apenas quando necessário, de modo que é importante entendê-los. Em contrapartida, não há muitos exemplos “complementares”. É natural que essa baixa frequência torne difícil a compreensão de alguns temas. Mas para isso existem os exercícios. nesse bloco explicíto coisas que o leitor deve prestar atenção. Na maioria dos casos, apresento causas comuns de erros. observações deste tipo costumam ser sobre a organização do livro ou outros esclarecimentos menos importantes. nesse tipo de bloco apresento referências que tratam do tema relevante com mais calma, ou trazem tópicos adicionais para o leitor que queira expandir seus conhecimentos. Ao final de cada capítulo existe uma seção de “Complemento”. Nele, há: Uma recapitulação dos conceitos apresentados. Uma lista de exercícios, que pode, inclusive, apresentar novos conceitos/funções. Uma lista de funções apresentadas no capítulo. Uma seção de referências, inclusive com links para conceitos deixados de lado no capítulo, para o leitor que quiser ir além. 1.5 Instalação, Interface, e Ferramentas Antes de começar o aprendizado, é preciso instalar a linguagem (R), e se familizarizar com a interface do editor de código oficial (RStudio). Veja como instalar neste tutorial do curso “R Para Jornalistas”. PS: coincidentenmente, a maneira que jornalistas instalam o R serve para qualquer outra profissão também. Existêm vários tutoriais online explicando a interface, como o da Datacamp (veja até “How to Write R Scripts in RStudio”) e este no video “RStudio for the Total Beginner”. Além disso, existem três configurações mais comuns de serem alteradas: alterar onde os arquivos são salvos por padrão (figura 1, “browse”); impedir que os dados da última vez que você entrou no R sejam recarregados quando você voltar (figura 1, “workspace”); e alterar aparência (figura 2). Todas elas podem ser encontradas na tab Tools &gt; Global Options: vide (Stephanie Locke 2017b), capítulo “3 - Using RStudio”, e/ou (James Long and Paul Teetor 2019), 3 - “Navigatin the Software”, para mais informações sobre a interface. Até o momento, eu fui preguiçoso e não trouxe esse material para o livro. Ainda assim, veja as referências com calma, não deixe confusões com o software atrapalharem seu aprendizado. Última coisa, eu juro. O R provê alguns comandos para procurar por ajuda. A função vignette() abre uma lista de artigos de ajuda das extensões do R. Adicionalmente, se você quer saber informações sobre uma função chamada “acaba_pelo_amor_de_deus”, os códigos abaixo abrem suas documentações de ajuda. Vejam mais sobre aqui, e aqui. ?acaba_pelo_amor_de_deus help(&quot;acaba_pelo_amor_de_deus&quot;) Agora sim, vamos começar. Boa sorte! Referências "],["parte-i---r-base-1.html", "Parte I - R Base", " Parte I - R Base Bem vindo à primeira parte deste livro, onde estudaremos os conceitos na base do R. Partirei do zero absoluto, de modo que é possível que o leitor tenha algum nível de familiaridade com os temas, mas provavelmente, não na profundidade aqui abordada. Nessa parte mais “teórica”, é difícil de traçar o limite no nível de complexidade ideal. Por conta disso, muitos conceitos tiveram de ser introduzidos rapidamente. Mas não se assute, muitas vezes, meu objetivo maior é passar uma intuição geral de como o R funciona, e dar um primeiro contato com os temas mais complexos. Tento ao máximo deixar claro onde gastar seu cérebro e onde nem tanto. Meu foco é mostrar a lógica do R, a “sintaxe e semântica” da linguagem. A “gramática/vocabulário”, isto é, funções, truques, e aplicações específicas, serão ensinadas de passagem e via exercícios. Mas no final, a ideia é ter apresentado a maioria das funções commumente relevantes, construindo uma lista de referência para futuras consultas. Os capítulos dessa seção estão organizados da seguinte maneira: Capítulo 2: aqui aprenderemos o básico sobre a sintaxe do R. Como imputar números e texto, o que são expressões e variáveis, e como realizar operações básicas. No geral, um capítulo bastante simples. Capítulo 3: a organização de tipos de dados no R é elegantemente simples, incluindo complexidade através da existência de metadados. A principal conclusão será entender a relação entre os diferentes tipos, porque esse conhecimento torna mais fácil pensar como uma mesma operação é aplicada em cada tipo de dado. Capítulo 4: nessa altura do campeonato, capaz que você esteja cansado de ver apenas teoria, esse capítulo é o mais “gramatical” de todos. Aprenderemos o que é a operação de selecionar e alterar partes de uma variável. Aqui, já fica claro o benefício de entender a organização dos tipos de dados. Capítulo 5: aprenderemos a controlar o fluxo de um programa, isto é, como fazer um programa tomar decisões e repetir operações. Aprenderemos também a lidar com erros e avisos. Capítulo 6: em oposição ao capítulo 3, agora é hora de dar atenção aos sentimentos do R. Estávamos utilizando-as, mas não explicamos o que são as funções. Esse é o capítulo mais desafiador, mas boa parte da dificuldade pode ser deixada de lado, com perdas reduzidas ao leitor. Capítulo 7: aqui, aprenderemos sobre os paradigmas/estilos de programação funcional, orientada ao objeto, e meta, especificamente sobre sua abordagem no R. A programação funcional é uma ferramenta com ligação direta nos projetos de ciência de dados; Entender o básico de POO no R é importante para entender o uso de funções[^Se chutou “objetos”, chutou errado.]; Metaprogramação é um assunto útil em si mesmo, mas especialmente importante para entender as bases do tidyverse na segunda parte do livro. Capítulo 8: por fim, temos algum outros tópicos úteis, mas não essenciais para o seguimento do livro. Aqui, aprenderemos sobre algumas ferramentas de melhoria de vida que o RStudio provê, e alguns temas avançados sobre gerenciamento de memória, performance, e organização. Recapitulado: não só em cada capítulo, mas cada parte deste livro, existe uma seção para retomar os conteúdos, especialmente o que será mais útil para a próxima parte. "],["syntax-vars.html", "Capítulo 2 Sintaxe e Variáveis 2.1 Sintaxe 2.2 Variáveis 2.3 Operadores Complemento", " Capítulo 2 Sintaxe e Variáveis 2.1 Sintaxe Em termos simplistas, um script é um arquivo de texto com instruções a serem executadas por um computador que antes traduzirá o arquivo para linguagem de máquina. Um script é um texto instrucional como qualquer outro, escrito em um tipo de linguagem especial, “de programação”, ou “código”, mas é um texto. Pode similar à receita de bolo de cenoura da minha vó, ou o roteiro da peça escolar onde interpretei, com maestria, a árvore #3. Como em qualquer linguagem, temos um vocabulário à disposição, um conjunto de palavras (ou tokens) existentes, organizadas em categorias como substantivos, adjetivos, etc. Nós combinamos as palavras em frases (ou statements) para descrever as instruções. Por fim, organizamos o texto em parágrafos (ou blocks), conjuntos de frases que devem ser lidas juntas, para definir a estrutura e facilitar o entendimento do texto. Ok, a receita da minha vó não tinha parágrafos, a metáfora não é perfeita, paciência. A seguir, vamos descrever com mais calma esses conceitos de tokens, statements, blocks, e script. 2.1.1 Palavras Vocabulário Quais palavras, tokens, temos disponíveis na linguagem R? Valores, que podem ser strings (palavras literais), números, valores booleanos (valores binários de verdadeiro ou falso), entre outros. Também podemos ter “coleções” desses dados (ex: vários números em uma “lista”). Variáveis, nomes associados à objetos. No futuro, veremos que podemos associar muito mais do que apenas dados à variáveis, por isso a nomenclatura mais geral “objetos”. Mais precisamente, a “palava” em si é o nome. Funções, que definem operações à serem realizadas usando variáveis/valores. Operadores, símbolos como + e &gt;, são um tipo de função especial, que apresentam uma sintaxe mais enxuta. Em termos simplificados, dados e variáveis são nossos substantivos (variáveis são “nomes próprios”), enquanto funções são nossos verbos. Como escrevemos essas palavras em um texto em R? Strings: utilize aspas duplas \" ou aspas simples': &quot;Hello World!&quot;, &#39;Hello World!&#39;1. Números: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01. Valores booleanos: escreva as palavras especiais TRUE e FALSE. Coleções: calma, tudo em seu tempo. Funções: escreva o nome da função, e os argumentos que ela receberá entre parênteses sum(1, 1). Não se preocupe muito com elas por agora. Operadores: são imputados como 1 + 1. Parênteses podem ser utilizados em operações matemáticas: (1+1)/2. Comentários: texto que não será avaliado como código. Use o símbolo #, que torna tudo após delena mesma linha, um comentário. Variáveis: já falei pra ter calma… 2.1.2 Frases Como dito, as frases no R serão combinações de tokens. Qualquer combinação. cada linha do código abaixo é uma frase: 1 1 + 1 a &lt;- 1 #define a variável &quot;a&quot; com valor &quot;1&quot; a #pede o valor da variável &quot;a&quot; sum(1, 1) sum(1, 1) + a Algumas frases são apenas um valor (1), o nome de uma variável (a), a chamada de uma função sum(1, 1){r}, ou a combinação dessas coisas. Na seção seguinte irei apresentar um resultado sobre isso. E quanto a um código como 1 +? Bom, esse código não é sintáticamente correto. Isso que estamos chamando de “frase”, quando sintáticamente correto, recebe o termo statement (declaração). A partir de agora, vou parar de usar “frase”, e usar o termo mais formal, declaração. 2.1.3 Parágrafos Como delimitamos declaração em parágrafos? Por padrão, uma declaração acaba na quebra de linha. Se a declaração terminar inacabada (como no exemplo 1 +), o R ignora a quebra de linha, e tenta completar a declaração com a linha seguinte. Um ponto e vírgula pode ser usado para delimitar uma declarações explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável. Várias declarações podem ser agregadas em grupos ou blocks usando chaves {}. Um grupo de declarações é avaliado apenas após seu fim. veja alguns exemplos de declarações. note que frases podem ser compostas de outras declarações: a #é uma declaração 1 #é uma declaração {1} #é a mesma declaração que a anterior 1 + 1 #é uma declaração, uma operação &quot;+&quot; sobre dois &quot;1&quot;&#39;s { 1 + 1 2 + 2 } #é um bloco de declarações 1 + 1; 2 + 2 #é a mesma declaração que a anterior a partir de aqui, “declaração” ou “statement” se refere a uma unidade ou a um grupo de declarações. Nada disso deve fazer muito sentido em termos práticos ainda, tudo bem, apenas é preciso já ir se acostumando com a estrutura geral de um programa. Antes de avançar, vou mentir um pouco e dar duas definições, mas que serão melhor detalhadas no futuro. Expressão É uma declaração não avaliada, “congelada”, que o R não rodou. Função É uma expressão, que depende de variáveis, associada à um nome. Utilizar esse nome, indicando os valores das variáveis envolvidas (entre parênteses ()), avalia a declaração, retornando seu resultado. liar &lt;- {x + y} #meramente ilustrativo, a sintaxe real é mais complexa liar(x = 1, y = 2) #&gt; 3 liar(1, 2) #equivalente à declaração anterior nos exemplos deste livro, um comentário no formato #&gt; ... indica o resultado esperado da declaração que o precede. Com essa definição em mente, vale incluir funções na nossa analogia de parágrafos, uma vez que também as usamos para organizar o texto. No capítulo 6, veremos que operadores são funções como qualquer outra, que apenas apresentam uma sintaxe diferente. 2.2 Variáveis Um dos tipos de palavras, as variáveis, merecem mais da nossa atenção. Mas não é para elas se acharem demais, dados e funções terão seus próprios capítulos. 2.2.1 Definindo Variáveis Para definir variáveis, escrevemos seu nome, = ou &lt;-, e a declaração que definirá seu valor: x = 1 + 1, x &lt;- 1 + 1. Também podemos usar a função assign(): assign(&quot;x&quot;, 1). Variáveis, nomes, e objetos Ao rodar algo como x &lt;- 1, o valor 1 é salvo na memória do computador, e associado ao nome x. Note que temos três parcelas: A informação salva na memória do computador (no exemplo, 1), é chamada de objeto. O nome associado à esse objeto (no exemplo, x), é chamado de, bom, nome. Variável se refere ao conjunto nome-objeto. No capítulo 3, veremos que “tudo que existe no R é um objeto”, isto é, esse conceito é muito abrangente. Por exemplo, na seção anterior, falei sobre as unidades que comõe declarações. Elas também são objetos. Objetos da linguagem Existem três tipos de objtos que compõe a linguagem R: names, nomes de variáveis. calls, chamadas de funções. expressions declarações não avaliadas. Note que expressões podem ser compostas de names e calls. Pense que valores, “objetos sem nome”, são efêmeros, por isso que não entram na lista acima. No futuro, ficará claro que termos tão poucos objetos compondo a linguagem é algo distintivo do R, e gerará resultados que, eu pelo menos, considero muito bonitos (e gosto não se discute). 2.2.2 Copy on Modify Com base no que aprendeu, como pensaríamos em y &lt;- x? A resposta não é nada óbvia. Note que temos duas opções: y pode ser um novo nome, associado ao mesmo objeto, mesma posição na memória do computador, que x. y pode ser um novo nome, associado a um novo objeto, nova posição na memória do computador, que x, mas carregando a mesma informação. No R, a realidade é a primeira opção. Porém, se y for alterado, x não é (e vice versa). O que ocorre é que uma nova posição na memória é criada para armazenar (ao menos parte da) informação do novo y. Esse processo, de apenas “separar”/“copiar” objetos quando modificados, é chamado de copy-on-modify. Diferentes tipos de dados terão diferentes relações com esse processo, mas vou poupá-los disso. O importante é saber que não temos os objetos são copiados quando modificados, alterar y não altera x e vice versa, independente da complexidade do objeto. Em outras palavras: Copy-on-modify No R, um mesmo objeto pode ter ser referenciado a mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças. Existem duas exeções: objetos com apenas uma referência, e ambientes2. Esses são alterados “na hora”/“no lugar”, ou modify-in-place. este tema é complexo, e foi bastante simplificado. Vide (Hadley Wickham 2019), seções “2.3 - Copy-on-modify” e “2.5 - Modify-in-place”. Os exemplos utilizando a função tracemem() são especialmente úteis. 2.2.3 Outras Características Note que = e &lt;- são muito similares, mas = serve para mais coisas que somente definição de variáveis, como indicar argumentos em uma função. Portanto, &lt;- funciona como “definidor” em mais contextos, e é uma má prática utilizar = como definidor. Ambos podem definir várias variáveis de uma vez: x = y = 3, x &lt;- y &lt;- 3, x = y &lt;- 3. Existe um terceiro operador &lt;&lt;-, que será discutido no capítulo 6. 2.2.4 Regras de Nomenclatura Nem toda combinação de caracteres pode ser um nome de variável. As principais regras são: Nomes podem conter letras, números, “.” e “_“. São “case-sensitive”. Podem começar apenas com letras ou “.”. Não podem ser palavras reservadas como “TRUE”. Nomes não sintáticos podem ser definidos, se escritos usando crases (backticks) “`”: `_x` &lt;- 1. Você provavelmente encontrará isso ao importar dados que não foram criados no R. Em muitos momentos, o R converte nomes não sintáticos utilizando a função make.names(). Você aprenderá sobre ela nos exercícios. É muito importante estar atento à esse comportamento, uma vez que é causa comum de erros. Você verá que isso é um tema comum: o R tenta fácilitar muitas tarefas, fazendo as coisas por você. Isso por um lado é o que o torna fácil de sair trabalhando, mas sempre é causa de inconsistências. 2.3 Operadores A princípio, deixaria os detalhes sobre operadores para os exercícios, mas fiquei com medo deles se sentirem excluídos. Abaixo estão os operadores relevantes para o momento, suas descições, e seu uso. Clique nos links dos operadores para abrir suas páginas de ajuda. Categoria Operador Descrição Uso aritmétrica + soma num + num aritmétrica - subtração num - num aritmétrica * multiplicação num * num aritmétrica / divisão num / num aritmétrica \\^ exponenciação num ^ num aritmétrica %% divisão inteira num %% num aritmétrica %/% resto da divisão num %/% num comparação == igual x == y comparação != diferente x != y comparação &lt; menor que num &lt; num comparação &gt; maior que num &gt; num comparação &gt;= maior igual num &gt;= num comparação &lt;= menor igual num &lt;= num lógica ! “não” lógico ! logi lógica &amp; “e” lógico logi &amp; logi lógica &amp;#124; “ou” lógico logi &amp;#124; logi na coluna de “Uso”, “logi” se refere a qualquer valor que se comporte como um valor booleano, “num” a qualquer valor que se comporte como número, “expr” à qualquer expressão, e “x”/“y” à valores mais genéricos, ou à nomes de variáveis. Agora vou apresentar a ordem de precedência da aplicação dos operadores. Associatividade se refere à como são resolvidos “empates”, “direita pra esquerda” significa que o operador mais à direita é analisado antes. Tudo ficará mais claro no exemplo seguinte. Operador Descição Associatividade (), {} agrupadores direita pra esquerda ::, ::: acessar namespaces (*) direita pra esquerda $, @ extração de components/slots (*) esquerda pra direita [, [[ indexação (*) esquerda pra direita ^ exponenciação esquerda pra direita -, + (unário) mais e menos unários esquerda pra direita : sequências (*) esquerda pra direita %%, %/%, %xyz%, &amp;#124;&gt; operadores especiais (*) esquerda pra direita *, / multiplicação, divisão esquerda pra direita +, - (binário) adição, subtração esquerda pra direita &gt;, &gt;=, &lt;, &lt;=, ==, != comparações esquerda pra direita ! “não” lógico esquerda pra direita &amp;, &amp;&amp; “e” lógico (*) esquerda pra direita &amp;#124;, &amp;#124;&amp;#124; “ou” lógico (*) esquerda pra direita ~ (unário e binário) fórmula (*) esquerda pra direita -&gt;, -&gt;&gt; definição pra direita (*) esquerda pra direita &lt;-, &lt;&lt;- definição pra esquerda (*) direita pra esquerda = (definidor) definição pra esquerda direita pra esquerda linhas com um “(*)” apresentam operadores que ainda não foram apresentados. para deixar mais claro, na declaração (3+6)/(1+2)/5^4 o seguinte ocorre: () são analizados primeiro, porque tem precedência (estão acima na tabela). Como é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9. ^ é analizado a seguir, logo, 5^4 vira 625. / é analizado a seguir. Como é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048. Vide (Stephanie Locke 2017b), capítulo “6 - Basic Operations” para mais detalhes e exemplos. Cuidado, alguns conceitos utilizados lá não foram vistos ainda. Complemento Recapitulando Sintaxe Neste capítulo, vimos a estrutura geral de um programa: As palavras do programa, podem ser valores, variáveis, ou funções. Valores serão o tema do próximo capítulo, e funções, do capítulo @(functions-environments). Vimos como imputar cada tipo de palavra. As frases (declarações) do programa são combinações de palavras. Costumam ser delimitadas por quebras de linha. Podem ser organizadas em parágrafos vias chaves, ou “nomeadas” via funções. Scripts, os programas escritos no R, são sequências de frases. Vimos definições inciais para dois conceitos importantes: Uma expressão é uma declaração ainda não avaliada. Uma função é uma expressão, que depende de variáveis, associada à um nome. Variáveis Também demos uma atenção extra ao conceito de variável, nome, e objeto: Variáveis são nomes associados à informações na memória do computador, os objetos. Aprendemos os operadores que definem variáveis = e &lt;-, e porque &lt;- é preferível. Vimos características como x &lt;- y &lt;- 3 e as regras de nomenclatura. Bem como alguns conceitos mais técnicos e avançados: A dinâmica da memória no R é pautada pelo conceito de copy-on-modify. No R, um mesmo objeto pode ter ser referenciado a mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças. As exeções são objetos com apenas uma referência, e ambientes, que usam modify-in-place (são modificados “no lugar”). O conceito de objeto é muito geral. Inclusive, a prória linguagem R é composta por (apenas) três tipos de objetos: names, calls, e expressions. Expressões são algo mais geral, podendo ser compostas de names e calls. Operadores Por fim, apresentamos os operadores básicos, seu uso, e ordem de preferência. Foi dito que operadores são funções, apenas com sintaxe diferente. Exercícios os exercícios usam variáveis de mesmo nome. Lembre-se de limpar as definições de variáveis após completar um exercício, rodando a frase rm(list = ls()). Variáveis Explique a diferença entre 1 e cada uma das variáveis abaixo. 1 a &lt;- 1 b &lt;- a c &lt;- a + 1 d &lt;- b e &lt;- 1 Foi comentado que objetos mais complexos têm comportamentos diferentes com relação ao processo de definição , mas todos seguem uma característica geral. Com base nisso, o que você espera que ocorra com b após a terceira linha do código abaixo? a &lt;- 1 b &lt;- list(a, a) a &lt;- a + 1 você verá a função list() no próximo capítulo, mas saiba que ela cria uma lista, uma coleção, dos elementos que a são passados como argumentos. Leia a página de ajuda da função make.names() para aprender as regras completas de definição de nomes, sobre como o R converte nomes não sintáticos. Preveja qual será o resultado das chamadas abaixo. make.names(&quot;&quot;) make.names(&quot;@&quot;) make.names(&quot;TRUE&quot;) make.names(&quot;`TRUE`&quot;) Operadores Parta de um número qualquer x, por exemplo, x &lt;- 5. Use os ensinados operadores para criar: Uma frase que retorne TRUE se x for múltiplo de 2. Uma frase que retonre TRUE se x não for múltiplo nem de 3, nem de 5. Uma frase que retonre TRUE se a parte inteira da divisão de x por 4 é igual a 2, ou se seu quadrado for maior ou igual à 10. Liste a ordem das ações executadas no cálculo da expressão abaixo: x &lt;- FALSE | !5.2 %% 2*7*4 - -3 &lt;= 100 &amp; TRUE Dicionário de Funções Abaixo segue a lista de funções vistas neste capítulo. Categoria Função Descrição Uso aritmétrica + soma num + num aritmétrica - subtração num - num aritmétrica * multiplicação num * num aritmétrica / divisão num / num aritmétrica \\^ exponenciação num ^ num aritmétrica %% divisão inteira num %% num aritmétrica %/% resto da divisão num %/% num comparação == igual x == y comparação != diferente x != y comparação &lt; menor que num &lt; num comparação &gt; maior que num &gt; num comparação &gt;= maior igual num &gt;= num comparação &lt;= menor igual num &lt;= num lógica ! “não” lógico ! logi lógica &amp; “e” lógico logi &amp; logi lógica &amp;#124; “ou” lógico logi &amp;#124; logi agrupadores { agrupador chaves { expr } agrupadores ( agrupador parênteses ( expr ) definidores &lt;-, -&gt; definidores x &lt;- expr, x -&gt; expr definidores = definidores x = expr definidores assign() definidores assign(\"x\", expr) outros rm() limpa objetos do ambiente rm(x) nomes make.names() NA NA ajuda help(), ? procurar ajuda na documentação help(x), ?x ajuda vignette() procurar vignettes vignette(x) Referências As referências principais deste capítulo são: (Hadley Wickham 2019) capítulo “2 - Names and Values”, excluindo as seções 2.4 e 2.6. (R Core Team 2024e) seções “2.1.3 - Language Objects” e “2.1.3 - Expression Objects”. (R Core Team 2024a) seções “2.1 - Vectors and Assingment” e “2.2 - Vector Arithmetic”. (R Core Team 2024d) seção “2.1 - SEXPs”. (R Core Team 2024f) os documentos de ajuda das funções aqui expostas. Vide (Hadley Wickham 2019) seções “2.4 - Object Size” e “2.6 - Unbinding and the Garbage Collector”. Referências "],["data-attrs.html", "Capítulo 3 Tipos de Dados e Atributos 3.1 Famílias 3.2 Vetores atômicos 3.3 Listas 3.4 Atributos Complemento", " Capítulo 3 Tipos de Dados e Atributos este capítulo está em construção. O que segue abaixo é apenas um rascunho. 3.1 Famílias 3.1.1 Tipos de Dados No R, os tipos de dados são organizados em “famílias”. Antes de entrar nesse mérito, abaixo estão os tipos mais importantes: Logicals são os dados booleanos, podem ser TRUE ou FALSE. Podem ser abreviados para T e F Characters são os dados de texto (strings) Intergers são números inteiros, e são escritos com um L no fim Doubles são os números decimais, podem ser decimais 1.245, científicos 1.23e4, ou hexadecimais 0xadfe Valores especiais: Inf, -Inf, e NaN (“not a number”, usado em indefinições matemáticas) Existem outros dois tipos menos utilizados: raw são os dados binários; complex são os números complexos Todos os tipos explicados assumem um valor especial, o “valor desconhecido”: NA (non aplicable) A maioria das operações envolvendo NA`s retorna um NA: 1 + NA #&gt; NA Como NA é um valor desconhecido, checar se um NA é igual ao outro não faz sentido NA == NA #&gt; NA Por trás dos panos, existe um NA diferente para cada tipo de vetor atômico (NA_interger_, etc.) Um dado “sozinho” (3) é chamado de scalar. Mas o R também apresenta “coleções” de dados: (1, 2, 3, 4, 5) Uma coleção de escalares de um mesmo tipo é um atomic vector Um escalar é uma “coleção de tamanho um”, e portanto, todo escalar é um vetor atômico Logo, não existe um objeto “sem estar em um vetor”. x &lt;- &quot;a&quot; é um vetor atômico de tamanho 1 Obs: os componentes de uma coleção são chamados de “elementos” Vetores atômicos não aceitam elementos de tipos diferentes, e não aceitam elementos que tamanho maior que um Porém, o R permite coleções com essas características, como (1, &quot;a&quot;, (1, 2, 3), TRUE, 1) 3.1.1.1 Definição Uma coleção de vetores é um generic vector, ou, mais comumente, uma list Um vetor genérico/lista também é um vetor, de modo que listas podem conter outras listas A lista tem seu próprio tipo, list Resumindo, temos: Os seis tipos “básicos” / tipos de escalares Vetores atômicos, coleções de escalares de mesmo tipo Mesmo quando seu tamanho é unitário (os próprios escalares) Vetores genéricos, coleções de vetores Não precisam ser atômicos, podem ter elementos de tipos diferentes Não precisam ser de escalares, podem ter elementos de tamanhos diferentes de 1 Consequentemente, podem conter qualquer vetor, atômico ou genérico (si mesmos) Apresentam seu próprio tipo, list 3.1.2 Famílias Como disse, os tipos de dados no R são organizados em “famílias”. Existem duas: Vector abrange os vetores atômicos e as listas. É a família dos dados “propriamente ditos” Node é a família de “dados internos” do R (funções, ambientes, etc.) Adicionalmente, NULL, um objeto especial, não é um vetor, mas pode ser entendido como a “ausência de dado”/“vetor de tamanho zero” A seguir, vamos entrar em detalhe sobre vetores 3.2 Vetores atômicos Você já deveria saber que x &lt;- 3 está criando um vetor atômico. Mas e para criar vetores atômicos mais longos? A função c() combina (daí o nome) vetores em um mais longo. Ela serve com atômicos ou genéricos, mas por enquanto, vamos usá-la com atômicos: c(TRUE, FALSE) c(1L) c(1, 3.5, 1.23e4) c(&quot;a&quot;, &quot;2&quot;) Quando usada com vetores atômicos, c() coage os inputs a escalares do mesmo tipo, resultando em um outro atomic vector Example 3.1 Qual o resultado do exemplo abaixo? c(c(1, 2), c(3, 4)) E abaixo? c(1, 2, &quot;a&quot;, &quot;b&quot;) Existe uma ordem de prioridade: se houver um character, tudo vira character, fora isso, tudo vira double, depois, interger, e por fim, logical Podemos testar o tipo de um vetor com is.logical(), is.integer(), is.double(), e is.character() Existem funções extras is.vector(), is.atomic(), e is.numeric(), mas são imprevisíveis Podemos transformar o tipo de um vetor com as.logical(), as.integer(), as.double(), ou as.character() As mesmas contrapartes existem aqui typeof() retorna o tipo de um vetor, length() retorna seu tamanho Obs: funções que pedem argumentos de um mesmo tipo normalmente os coagem caso eles não o sejam 3.3 Listas Características gerais: O typeof() de uma list é &quot;list&quot; Diferentemente dos V.A., uma lista de tamanho 1 não é um escalar list() cria uma nova lista is.list() e as.list() unlist() transforma uma lista em um vetor atômico, mas de maneiras inesperadas No futuro, trataremos das funções do pacote purrr No tema de “Gerenciamento de memória” falaremos sobre como, por trás dos panos, listas são apenas referências aos objetos, de modo que list(x, x) ocupa bem menos que o dobro do espaço de list(x) c() também pode combinar listas Example 3.2 Analize, desenhe, e compare os objetos abaixo: l1 &lt;- list(list(1), list(2)) l2 &lt;- list(list(1), 1) l3 &lt;- list(list(1,2,3), c(1,2,3)) l4 &lt;- c(list(1), list(2)) l5 &lt;- c(list(1), 2) l6 &lt;- c(list(1,2,3), c(1,2,3)) Basicamente, a função list() cria “caixinhas” para cada um de seus argumentos, enquanto a função c() não o faz 3.4 Atributos Os vetores podem carregar mais informações do que apenas os valores de seus elementos, eles podem carregar metadados (dados que informam algo sobre os elementos), os atributos Existem três atributos principais: names, um vetor character, que nomeia cada elemento dim (diminutivo de dimentions), um vetor interger, que reorganiza vetores em matrizes e arrays (“matrizes multidimensionais”) class, um vetor character, que indica um “tipo 2.0”, alterando o comportamento dos vetores Atributos não afetam a estrutura básica (tipo) dos objetos, mas podem afetar seu comportamento 3.4.1 Nomes Podemos nomear um vetor de várias formas: x &lt;- c(a = 1, b = 2, c = 3) names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x &lt;- setNames(x, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) (ou a função set_names() do pacote purrr) Podemos remover nomes com: x &lt;- unname(x) Example 3.3 Que valor/objeto colocaríamos em y para remover os nomes? names(x) &lt;- y É fácil ver como a estrutura básica fica inalterada. Tente transpor essa ideia para os outros atributos mais complexos 3.4.2 Dimensões Um vetor com o atributo dimensão é um vetor que deve ser interpretado como organizado em linhas e colunas (para matrizes): m1 &lt;- c(T, F, T, T, F, T) dim(m1) &lt;- c(2, 3) #ou matrix(c(T, F, T, T, F, T), nrow = 2, ncol = 3) Ou como organizado em matrizes multidimensionais (para arrays): a1 &lt;- c() dim(a1) &lt;- c(2, 3, 2) #ou array(1:12, c(2, 3, 2)) Também podemos ter matrizes e arrays feitas com listas: m2 &lt;- list(1, 2, &quot;c&quot;, list(&quot;d&quot;), TRUE, c(3, 4)) dim(m2) &lt;- c(2, 3) Example 3.4 Que lista complexa! Como poderíamos desenhá-la? E sua versão de matriz? Uma matriz ou array sempre é atômica? O que aconteceria com os outros elementos se eu alterasse o primeiro elemento de m1 para &quot;a&quot;? E se eu fizesse o mesmo com m2? Como atributos não alteram a estrutura básica, as funções para vetores tem generalizações para matrizes e arrays: Vector Matrix Array names() rownames(), colnames() dimnames() length() nrow(), ncol() dim() c() rbind(), cbind() abind() is.vector is.matrix() is.array() Note que adicionar dimensões gerou algumas possibilidades Um tamanho e um atributo de nome para cada dimensão Maneiras diferentes de combinar objetos Operação de transposição (com t() e aperm()) 3.4.3 Classes Outro attributo importante é class, que permite a criação de vetores diferenciados, criados em cima dos tipos básicos Esse atributo empodera o sistema de programação orientada ao objeto S3. Nele, funções agem diferentemente a depender da classe do argumento que estão recebendo. Abaixo vão algumas: factor são intergers para dados categóricos Date, POSIXct, e difftime são doubles para datas data.frame e tibble são lists para bases de dados Existem outros como ts para séries de tempo, uma classe para cada tipo de vetor estudado, entre outros Obs: existem outras famílias de classes 3.4.3.1 Factors Factors tem o atribuito class como &quot;factor&quot;, e um atributo levels que define os valores/categorias possíveis factor(c(&quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;), levels = c(&quot;m&quot;, &quot;f&quot;, &quot;o&quot;)) #&gt; [1] m f f m #&gt; Levels: m f o Cuidado, factors comumente geram erros Também existem os ordered factors, onde indicamos uma ordem para os levels, e costumam ser usados em funções de modelagem e visualização (vide ordered()) 3.4.3.2 Datas Dates: são um double com o atributo class &quot;Date&quot;. Por trás dos panos são o número de dias desde 01/01/1970. Para criar: as.Date(&quot;1970-02-01&quot;) Date-times: são um double com o atributo class &quot;POSIXct&quot;. Por trás dos panos são o número de segundos desde 01/01/1970. Para criar: as.POSIXct(&quot;2018-08-01 22:00&quot;, tz = &quot;UTC&quot;) Durations: são um double com o atributo class &quot;difftime&quot;, que conta a distância entre duas datas. Têm o atributo &quot;units&quot; que indica como o valor deve ser interpretado. Para criar: as.difftime(1, units = &quot;weeks&quot;) 3.4.3.3 Data frames Um data frame é uma representação de uma tabela de dados. Basicamente, uma lista nomeada de vetores, normalmente atômicos, de mesmo tamanho: list(coluna1 = c(1, 2, 3), coluna2 = c(&quot;c&quot;, &quot;b&quot;, &quot;d&quot;), coluna3 = c(TRUE, FALSE, NA)) Como sempre, ter isso em mente ajudará muito a transpor o conhecimento sobre listas para data frames Data frames têm os atributos names (nomes das “colunas”), row.names (nomes das “linhas”), e a class &quot;data.frame&quot; Funções úteis: São criados com data.frame() Um data frame tem nrow() linhas E ncol()/length() colunas Também existem as funções “is” e “as” Uma coluna de um data frame pode também ser uma matriz/array (se o número de linhas coincidir), ou uma lista (se o número de itens coincidir) Um Tibble é um sucessor data frame trazido pelo pacote “tibble” (parte do tidyverse). Tibbles são “preguiçosos e grosseiros: fazem menos e reclamam mais”: Tem a class c(&quot;data.frame&quot;, &quot;tbl_df&quot;) Não geram vetores maiores a partir de vetores menores (data.frame(x = 1:4, y = 1:2)) Não mudam nomes não sintáticos Não aceitam rownames (“metadata is data”) Um subset de um tibble sempre é um tibble Não tem matching parcial nos nomes de colunas Permitem referenciar colunas na hora da criação (tibble(x = 1:4, y = 2*x)) Tem uma melhor visualização no console Algumas funções relacionadas à atributos: atributes(x) retorna uma lista com os atributos de x attr(x, &quot;attr&quot;) retorna o valor do atributo &quot;attr&quot; Atributos importantes têm funções próprias (names(), dim(), class()) unclass(x) remove a classe de x, retornando-o ao tipo base structure(x, &quot;attr&quot; = valor) adiciona os atributos especificados em x str(x) retorna uma visualização da estrutura de x Obs: a maior parte pode ser usada para definir/alterar valores de atributos Complemento Recapitulando Como imputar valores “Definições” de expressão, função, e objeto (&amp; nome) Criação de variáveis Operadores de definição = e &lt;- Regras de nomenclatura Definição. Metadados que alteram algo sobre o vetor names alter visualização e como referenciar os elementos dim altera como o elemento é organizado, e é aplicável à todo tipo de vetor typeof()/class() e funções “as” e “is” (extra: is.na()) Funções criadoras c(), list(), matrix(), array(), factor(), odered(), data.frame(), tibble(), unlist() Funções combinadoras c(), cbind(), rbind(), e pacote “abind” Funções sobre dim: dim(), length(), nrow(), ncol() Funções sobre names: names, colnames(), rownames(), dimnames(), setNames()/set_names(), unname() Funções sobre atributes: str(), atributes(), attr(), structure(), unclass() Outras: t(), I() (extra: stringsAsFactors = FALSE) Exercícios Example 3.5 3.4.3.4 Vetores atômicos Porque 1 == &quot;1&quot; é verdadeiro? Porque -1 &lt; FALSE é verdadeiro? Porque &quot;one&quot; &lt; 2 é falso? Agora com operações aritmétricas. 1 + “2” funciona? e TRUE + 1? Qual é a regra? Porque o NA padrão é um vetor lógico? Pense no resultado de c(FALSE, NA_character_) Trabalhamos exemplos envolvendo c() e listas. Busque na página de ajuda ?c() pela ordem completa de coerção O que &quot;a&quot; == c(&quot;a&quot;) retorna? e identical(&quot;a&quot;, c(&quot;a&quot;))? Estude o argumento recursive = TRUE de c(). O que ele faria em: c(list(1), list(2)), c(list(1), 2), c(list(1,2,3), c(1,2,3))? Example 3.6 3.4.3.5 Listas Estude os objetos abaixo. Desenhe-os: l1 &lt;- list(1:3, &quot;a&quot;, c(T, F, T), c(2.3, 5.9)) l2 &lt;- list(list(list(1))) l3 &lt;- list(list(1, 2), c(3, 4)) l4 &lt;- c(list(1, 2), c(3, 4)) Faça o mesmo, agora estudando o tipo e classe: l5 &lt;- list(1:4, &quot;a&quot;, list(&quot;a&quot;), matrix(1,2,3)) l6 &lt;- l5; dim(l6) &lt;- c(2,2) l7 &lt;- as.data.frame(l6) Example 3.7 3.4.3.6 Atributos Como setNames() funciona? Como unname() funciona? Olhe o código fonte O que dim() retorna quando applicado a um vetor unidimensional? Quando NROW() e NCOL() podem ser úteis? Como você descreveria os objetos abaixo? Qual a diferença entre eles e 1:5? x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Example 3.8 3.4.3.7 Vetores atômicos S3 O que faz a função table()? Que objeto retorna? Qual seu tipo? Quais seus atributos? Como sua dimensão muda ao adicionar variáveis para tabular? O que acontece com um factor ao alterar seus níveis? f1 &lt;- factor(letters) levels(f1) &lt;- rev(levels(f1)) O que o código abaixo faz? como f2 e f3 diferem de f1? f2 &lt;- rev(factor(letters)) f3 &lt;- factor(letters, levels = rev(letters)) Example 3.9 3.4.3.8 Listas S3 Pode haver um data frame com zero linhas? E zero colunas? O que ocorre se você definir rownames não únicos? Se df é um data frame, o que é t(df)? Porque? E t(t(df))? O que as.matrix() faz quando aplicada a um data frame com colunas de tipos diferentes? Como isso difere de usar data.matrix()? Example 3.10 3.4.3.9 Listas S3 Estude o objeto abaixo. As colunas tem a mesma length? Existe alguma outra medida de dimensão igual? Isso faz sentido? x &lt;- data.frame(a = 1:2) x$b &lt;- c(matrix(1, 1, 1), matrix(2, 1, 1)) x$c &lt;- list(matrix(1, 1, 1), matrix(2, 1, 1)) x$d &lt;- data.frame(c1 = factor(c(&quot;a&quot;, &quot;b&quot;))) Dicionário de Funções Referências "],["subset.html", "Capítulo 4 Subsetting 4.1 Introdução 4.2 Operador [ 4.3 Operador [[ e $ 4.4 Atribuição 4.5 Aplicações Complemento", " Capítulo 4 Subsetting este capítulo está em construção. O que segue abaixo é apenas um rascunho. 4.1 Introdução Falamos sobre vetores, agora falaremos sobre como selecionar/alterar seus elementos Existem três operadores, [, [[. e $. Começaremos com [ A sintaxe geral é x[...], podemos usar várias técnicas diferentes no lugar de “…” Para os exemplos: x &lt;- c(1.3, 7.4, 6.0, 5.9) m &lt;- matrix(1:9, nrow = 3, ncol = 3) colnames(m) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) df &lt;- as.data.frame(m) l &lt;- list(&quot;a&quot; = 1:3, &quot;b&quot; = &quot;oi&quot;, &quot;c&quot; = 4:6) 4.2 Operador [ Existem seis maneiras: Inteiros positivos: retornam elementos nas posições x[1] #&gt; 1.3 x[1:3] #&gt; 1.3 7.4 6.0 x[c(1,3)] #&gt; 1.3 6.0 Obs1: índices decimais são truncados: x[1.7] == x[1] Obs2: factors são tratados como intergers Inteiros negativos: retornam todos os elementos menos os das posições x[-c(1,3)] #&gt; 7.4 5.9 Vetores lógicos: retornam os elementos nas posições onde tem-se TRUE’s x[c(TRUE, TRUE, FALSE, FALSE)] #&gt; 1.3 7.4 O vetor lógico deve ser do mesmo tamanho. O R tenta corrigir transgressões, mas as regras de “reciclagem” são confusas (x[c(TRUE, FALSE)]) Vetores de texto: retornam os elementos com os nomes escolhidos c(a = 1, b = 2, c = 3)[c(&quot;a&quot;, &quot;c&quot;)] #&gt; 1 3 Nada: x[] retorna o vetor original Zero: retorna um vetor de tamanho 0 Obs: todos esses métodos podem reordenar os elementos x[c(1, 3, 2)] Com matrizes (vetores com dimensão), existem três maneiras: Múltiplos vetores: um vetor para cada dimensão m[c(TRUE, FALSE, TRUE), c(&quot;B&quot;, &quot;A&quot;)] Um vetor omisso retorna todos os “elementos da dimensão”: a[, c(1, 3)] Para arrays, use um argumento para cada dimensão a[1:2, 2, , 4] Vetor único: como matrizes são vetores, podemos tratá-las como tal m[5:7] do elemento 5 até o 7 (a ordem é “column-major”) Podemos usar uma matriz lógica aqui, similar à usar um vetor lógico Matrizes seletoras: onde cada coluna é uma dimensão, e cada linha um elemento quisto m[rbind(c(1,1), c(3,1), c(2,4))] Para arrays, precisamos de três ou mais colunas Listas: mesmas maneiras que com vetores atômicos. [ sempre retorna uma lista, mesmo ao selecionar um único elemento Example 4.1 E para data frames? O que df[1:2] deve retornar? E df[1:2, ]? É “natural” que esses métodos coexistam? O operador [ simplifica a dimensão do resultado Em matrizes/arrays, dimensões de length 1 são desfeitas m[1,], e m[,1] Com vetores únicos, todas são: m[1:9] Data frames no “modo matriz” sofrem o mesmo, mas apenas para colunas df[1,] Mas df[,1] e df[1] mantêm a dimensão Isso é controlado pelo argumento drop = TRUE do operador. Podemos alterá-lo: df[1, , drop = FALSE] Tibbles tem drop = FALSE por padrão, sempre retornando outra tibble/nunca simplificando (alá a preguiça) 4.3 Operador [[ e $ Para selecionar um único elemento, podemos usar os operadores [[ ou $ Para pegar um elemento, e não uma lista, precisamos usar l[[&quot;a&quot;]] no lugar de l[&quot;a&quot;] Example 4.2 Porque não existe essa diferenciação para vetores atômicos (x[1] == x[[1]])? Pode ser útil usar [[ mesmo assim? l$a é uma abreviação de l[[&quot;a&quot;]]. Diferença: $ faz “matching parcial” (da esquerda pra direita). Duvido vocês adivinharem se tibbles fazem isso ou não O operador [[ reage de maneiras estranhas quando se pede um elemento que não existe, as vezes retorna erro, as vezes NULL. Para lidar com isso, foram criadas as funções: purrr::pluck() sempre retorna NULL (ou um valor definido pelo usuário) purrr::chuck() sempre retorna um erro Obs: existem também @ e slot(), similares a $ e [[ que servem para objetos S4 e não serão tratados aqui 4.4 Atribuição Todos os operadores podem ser combinados com &lt;-, numa operação chamada de sub-atribuição O formato geral é x[i] &lt;- valor. Alguns comentários: Cheque se length(x[i]) == length(valor). Pode gerar erros ou resultados inesperados via reciclagem Podemos reassinalar mais de um elemento por vez Com listas, lembre que l[i] sempre é uma lista l[i] &lt;- list(valor) é similar à l[[i]] &lt;- valor l[[i]] &lt;- NULL remove o item da lista, enquanto l[i] &lt;- list(NULL) altera o item para NULL Podemos “alterar o conteúdo de um objeto” (mantendo sua estrutura) no lugar de “alterar o objeto em si”, usando o subset vazio df[] &lt;- as.list(df) versus df &lt;- as.list(df) 4.5 Aplicações Example 4.3 4.5.0.1 Lookup vectors Dado o vetor de abreviações abaixo, como criar o vetor extenso (“male” e “female”) x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;) Resposta: lookup &lt;- c(m = &quot;Male&quot;, f = &quot;Female&quot;, u = NA) lookup[x] Example 4.4 4.5.0.2 Lookup tables Agora, queremos fazer o match de um vetor de “tipos” com a tabela que descreve cada tipo grades &lt;- c(1, 2, 2, 3, 1) info &lt;- data.frame(grade = 3:1, desc = c(&quot;Good&quot;, &quot;Med.&quot;, &quot;Poor&quot;), fail = c(F, F, T)) Resposta: info[match(grades, info$grade), ] Para merges mais complexos, usaremos as funções merge() e dplyr::left_join() Example 4.5 4.5.0.3 Amostragem aleatória A função sample(x, n) escolhe n elementos aleatórios do vetor x. Como podemos utilizá-la para tirar uma amostra de um data frame? df &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5]) Resposta: df[sample(nrow(df)), ] df[sample(nrow(df), 3, replace = TRUE), ] Example 4.6 4.5.0.4 Expandindo linhas identicas É comum data frames terem uma coluna de “quantas vezes uma observação aparece”. A função rep(x, y) repete cada entrada i do vetor x y[i] vezes. Como podemos usá-la para expandir linhas? df &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1)) Resposta: df[rep(1:nrow(df), df$n), ] Example 4.7 4.5.0.5 Seleção negativa com characters Com índices, podemos usar - para fazer seleção negativa. Para nomes, use a função which() e/ou setdiff(). Resposta: df[setdiff(names(df), &quot;n&quot;)] df[which(names(df) !%in% c(&quot;a&quot;, &quot;b&quot;))] Example 4.8 4.5.0.6 Filtragem de datasets com condições Como selecionar apenas as linhas do dataset mtcars cujo valor de “cyl” seja maior que 4? Resposta: mtcars[mtcars$cyl &gt; 4, ] mtcars[mtcars$cyl &gt; 4 &amp; mtcars$gear == 5, ] Complemento Recapitulando Vimos que existem seis maneiras básicas de acessar elementos de um vetor com [: Inteiro positivo com índices dos elementos quistos Inteiro negativo com índices dos elementos à ignorar Vetore lógico com TRUE nos índices dos elementos quistos Vetore de texto com os nomes dos elementos quistos Nada, x[], retornando o vetor original Zero, retornando um vetor de tamanho 0 Adicionalmente, aprendemos sobre o comportamento de simplificação de dimensões (drop = TRUE) Sabendo as características dos tipos de dados (aula I.1) é fácil saber aplicar tais métodos aos diferentes objetos: Com matrizes, podemos: Tratá-las como vetores (ordem “column-major”) Usar vetores atômicos ou até matrizes de mesmo tamanho Tratar cada dimensão como uma seleção independente Uso especial do método “Nada” Usar matrizes seletoras Com listas, podemos: Usar os mesmos métodos, retornando uma sub-lista Usar [[ e $ para selecionar elementos específicos Com data frames, podemos tratá-los como matrizes ou listas, usando todos os métodos acima Estudamos também algumas aplicações Lookup vectors Lookup tables Resampling Ordenação Expansão de linhas agregadas Logical subsetting Exercícios Dicionário de Funções Referências "],["control-conds.html", "Capítulo 5 Control Flow e Condições 5.1 Introdução 5.2 Choices 5.3 Loops 5.4 Condições Complemento", " Capítulo 5 Control Flow e Condições Aviso: este capítulo está em construção. O que segue abaixo é apenas um rascunho. 5.1 Introdução As ferramentas de control flow são aquelas que alteram a ordem de execução de um dado código No R, temos dois grupos principais: Choices, com if, else, switch(), e ifelse() Loops, com repeat, while, e for 5.2 Choices 5.2.1 If &amp; else Podemos criar uma expressão que apenas é avaliada se uma certa condição for verdade. Se não for, podemos complementar com expressões auxiliares: x &lt;- 60 if (x &gt; 90) { &quot;A&quot; } else if (x &gt; 80) { &quot;B&quot; } else if (x &gt; 50) { &quot;C&quot; } else { &quot;F&quot; } Características gerais: Podemos escrever essas expressões em uma linha, sem “{” Podemos utilizá-las para assinalar valores: x &lt;- if (TRUE) 1 else 2 Se não houver nenhum else, if retorna um NULL Example 5.1 O que o código abaixo vai retornar? Obs: paste() une as strings num &lt;- runif(1) #sorteia um número entre 0 e 1 paste(&quot;o número escolhido foi&quot;, num, if (num &gt; 0.5) &quot;e ele é maior que 0.5&quot;) A função ifelse() funciona para um vetor de condições, diferentemente de if, que exigia um único valor booleano Para cada elemento, ela checa a condição, e avalia uma ou outra expressão, salvando os resultados em um vetor Example 5.2 O que o código abaixo vai retornar? x &lt;- 1:10 ifelse(x &gt; 5, NA, x) 5.2.2 And and e or or Existem os operadores “and and” &amp;&amp; e “or or” || que garantem sempre um único valor booleano (dão erros com vetores longos), além de serem “short circuit”: c(FALSE, TRUE) &amp;&amp; TRUE #&gt; erro por usar vetor longo c(FALSE) &amp;&amp; stop() #&gt; FALSE pois para no `FALSE` c(FALSE) &amp; stop() #gera erro, #&gt; erro, pois não para no `FALSE` Por isso, use &amp;&amp; e || em if, e &amp; e | em ifelse() 5.2.3 Switch Existe uma maneira mais simples de escrever uma expressão if de “escolha de opções”, com a função switch(): if (x == &quot;a&quot;) { &quot;option 1&quot; } else if (x == &quot;b&quot;) { &quot;option 2&quot; } else if (x == &quot;c&quot;) { &quot;option 3&quot; } else { stop(&quot;`x` inválido&quot;) } switch(x, a = &quot;option 1&quot;, b = &quot;option 2&quot;, c = &quot;option 3&quot;, stop(&quot;`x` inválido&quot;) ) 5.3 Loops 5.3.1 Loops For Loops for são usados para iterar em elementos de um vetor: for (item in vector) expr item é literalmente um objeto, cujo valor vai sendo atualizado a cada iteração, e fica armazenado no ambiente global A keyword next pula para a próxima iteração, e break termina o loop Example 5.3 Como será a ordem do loop abaixo? for (i in 1:10) { if (i &lt; 3) next print(i) if (i &gt;= 5) break } Dicas gerais: Ao usar um loop para criar uma variável, crie o “conteiner” de antemão, pois é bem mais rápido: x &lt;- NULL; for(i in 1:5) x &lt;- c(x, i) x &lt;- NULL; for(i in 1:5) x[[i]] &lt;- i Prefira usar seq_along(x) no lugar de 1:legth(x) Cuidado que loops costuma remover atributos. Use seq_along() e acesse os itens você mesmo x &lt;- as.Date(c(&quot;2020-01-01&quot;, &quot;2010-01-01&quot;)) for (i in x) print(i) 5.3.2 Outros loops Se você não tem um veror de opções de antemão, não sabe sobre quais valores quer iterar, você pode: Usar um loop while (condition) {...}, que repete uma ação enquanto uma condição valer Ou, ainda mais flexível, repeat(...), que repete uma ação para sempre até encontrar um break É uma boa prática usar a opção menos flexível possível, para dar menos brechas para erros. Prefira usar o for, ou apply e purrr::map (tratadas no futuro) 5.4 Condições Seção sobre condições. Complemento Recapitulando Por fim, estudamos as ferramentas de control flow: Choices, com if, else, switch(), e ifelse() Loops, com repeat, while, e for Aprendemos alguns conhecimentos específicos de if, operadores com &amp;&amp;, e observações específicas do loop for Subsetting: [, [[, $ (argumento drop) purrr::pluck() e purrr::chuck() Aplicações com match(), sample(), setdiff(), which() Control flow: Choices: if, else, ifelse() e switch() Operadores &amp;&amp; e || Loops: repeat, while, e for Função seq_along() Keywords: next, break Exercícios Dicionário de Funções Referências "],["funs-envs.html", "Capítulo 6 Funções e Ambientes 6.1 Fundamentos 6.2 Ambientes 6.3 Scoping e Evaluation 6.4 Conceitos Adicionais Complemento", " Capítulo 6 Funções e Ambientes este capítulo está em construção. O que segue abaixo é apenas um rascunho. 6.1 Fundamentos 6.1.1 Introdução Funções no R são expressões que salvamos como um objeto, para utilizá-las repetidas vezes, variando seus argumentos Elas são criadas com a seguinte sintaxe: fun_name &lt;- function(x, y) { x + y } #ou fun_name &lt;- \\(x, y) { x + y } fun_name(1, 2) #&gt; 3 Elas têm três componentes: Seus argumentos (x e y), acessados com formals(fun_name) Seu corpo (x + y), acessado com body(fun_name) Seu enviroment, um objeto que determina onde a função deve procurar os valores das variáveis relevantes As únicas exceções existem no R base, e são escritas em C em vez de R, por performance. Elas são as funções primitivas, e não tem os componentes: sum #&gt; .Primitive(\"sum\") Como dito, as funções são objetos, criadas da mesma forma que x &lt;- 3. Esse é o conceito de funções first-class Como qualquer objeto: Elas tem um tipo. “closure”, ou para as primitivas “builtin” e “special” Podem ser passadas como argumentos para outras funções Podem ser salvas em listas funs &lt;- list(half = function(x) x / 2, double = function(x) x * 2) funs$double(10) #&gt; [1] 20 Funções anônimas: note que não precisamos atribuídas um nome à uma função. Muito comum ao passar funções à outras Call’s alternativas: podemos passar os argumentos via uma lista com a função do.call(): do.call(fun_name, list(x = 1, y = 2)) #&gt; 3 Recursividade: funções no R podem chamar elas mesmas. Vide o exemplo abaixo: recursive_factorial &lt;- function(x) { if (x == 0) return(1) else return(x * recursive.factorial(x - 1)) } Argumentos padrão: podemos deixar um argumento pré-definido: function(x, y = 1) ... 6.1.2 Formatos e combinações No R, “Everything that exists is an object. Everything that happens is a function call” -John Chambers Example 6.1 6.1.2.1 Exemplo Qual conceito visto hoje exemplifica a primeira parte do slogan acima? A segunda parte do slogan fica clara ao saber que operadores e keywords também são funções, apenas com outro formato A mais comum é o formato prefix: fun(x, y, ...). Veremos que os outros três podem ser escritos assim Infix: a função vai no meio de seus argumentos, x + y Modo prefix: `+`(x, y) Para definir use um nome que começe e termine com “%”: %&amp;% &lt;- \\(x, y) paste(x, y) Replacement: funções que alterem valores de um objeto: names(df) &lt;- ... Modo prefix: `names&lt;-`(df, ...) Como definir Special: funções muito importantes para o R, cada uma com uma forma própria, como [[, if, and for `if`(x &gt; 0, x, x * (-1)) `for`(var, seq, action) `next`(), e `break`() Obs: use isso para achar a documentação de funções ?`[` Existem três formas de combinar funções: Nesting: g(f(x)), f realiza sua operação em x, e o resultado vira argumento para g É enxuto para pequenas expressões, mas pode ficar confuso em expressões muito longas Objetos intermediários: y &lt;- f(x); z &lt;- g(y) Bom quando os valores intermediários são importantes, mas desnecessário quando não são Piping: os operadores |&gt; e magrittr::`%&gt;%` chamam “pipe” (cano). Eles transformam a avaliação de “dentro para fora” em “da esquerda pra direita”: f(x) %&gt;% g() Facilita a leitura de expressões longas, mas só serve quando é apenas um objeto que irá “avançar” ao longo da função 6.2 Ambientes Um enviroment é como uma lista nomeada, que associa nomes de variáveis aos seus valores. São neles que as funções buscarão os valores das variáveis Ambientes são objetos (como tudo que existe no R), com tipo “enviroment”, onde: Todos os nomes devem ser únicos Não existe uma ordem nos elementos Todo ambiente tem um um “ambiente pai” São o único tipo de objeto que não é copied when modified No R, as funções salvam o ambiente onde foram criadas como parte de si, “they enclose their enviroments”, são closures Portanto, o lugar onde buscam as variáveis não muda a depender de onde foram chamadas Funções criam um ambiente próprio para serem executadas: Filho de onde foram criadas Contém os argumentos, e os valores criados em seu corpo As funções buscam valores nos ambientes, começando pelo próprio, e avançando para os ambientes-pai até encontrar a variável procurada base: é o ambiente da pacote base do R, o pacote que carrega todos os outros Ambientes para pacotes: na ordem de chamada, pelo R (pacotes built-in), e depois pelo usuário (via library()) Ambiente global: o ambiente diretamente interativo Ambiente temporário: execução de funções 6.3 Scoping e Evaluation 6.3.1 Scoping Agora sim podemos falar sobre como uma função busca por valores, a operação de scoping 6.3.1.1 Definição O método utilizado pelo R é o lexical scoping (parse-time) e segue quatro regras principais (abaixo) Name masking: nomes/objetos definidos dentro de uma função, e seus argumentos, “mascaram” nomes definidos fora da função O R só buscará uma variável no ambiente-pai, se não encontrá-la no ambiente da função “Tudo que existe é um objeto”, logo a regra acima também vale para a busca de funções Se uma função e um objeto tem mesmo nome, R interpreta nome() como sendo a função, e nome como o objeto Início do zero: um novo ambiente temporário é criado a cada chamada Não armazenamos informação de chamadas passadas, cada chamada é independente (a menos que explicitamente se defina o contrário) Dynamic lookup: as funções buscam os valores na hora da chamada, não quando são criadas O “onde” não muda (closures), mas o “quando” sim Resultados podem diferir antes e depois de se alterar uma variável relevante do ambiente global Example 6.2 6.3.1.2 Name masking Qual será o resultado do código abaixo? a &lt;- 1; b &lt;- 2; c &lt;- 3 f &lt;- function(b) { a &lt;- 10 c(a, b, c) } f(b = 20) Resposta: #&gt; [1] 10 20 3 Example 6.3 6.3.1.3 Name masking com funções Qual será o resultado do código abaixo? f &lt;- function(x) x + 1 g &lt;- function() { f &lt;- function(x) x + 100 f(10) } g() Resposta: #&gt; [1] 110 Example 6.4 6.3.1.4 Início do zero Qual será o resultado do código abaixo? x &lt;- 1 f &lt;- function() x &lt;- x + 1; x f() f() x Resposta: #&gt; [1] 2 #&gt; [1] 2 #&gt; [1] 1 Example 6.5 6.3.1.5 Dynamic lookup Qual será o resultado do código abaixo? f &lt;- function() x + 1 x &lt;- 1 f() x &lt;- 100 f() Resposta: #&gt; [1] 2 #&gt; [1] 101 6.3.2 Lazy evaluation Falamos sobre como os valores dos argumentos são buscados na hora da chamada, mas podemos ser mais específicos 6.3.2.1 Definição Os argumentos são lazily evaluated: só são avaliados quando “acessados”. Isso é feito via armazená-los em um tipo de dado chamado promessa, que tem três componentes: Uma expressão, que será calculada no futuro O ambiente onde ela deve ser avaliada Um valor, o resultado da expressão, que substitui a promessa após ser calculado Isso permite incluir argumentos padrão que dependam de outros argumentos: f &lt;- function(x = 1, y = x * 2, z = a + b) { a &lt;- 3; b &lt;- 4 c(x, y, z) } Além de incluir argumentos que possivelmente exigem muita computação, sem gerar custo quando não forem utilizados: mean_unif &lt;- function(a, b, sim = FALSE, x = runif(1000, a, b)) { if (sim) mean(x) else (a + b)/2 } 6.4 Conceitos Adicionais 6.4.1 Dot dot dot Funções podem ter o argumento especial ... pronunciado “dot-dot-dot”, mas muitas vezes chamado de “varargs” em outras linguagens Ele é útil se você não sabe listar todos os argumentos que sua função pode vir a receber: Em funções que recebem funções como argumento (como lapply()) Em funções genéricas (passar argumentos para métodos) function(x, fun, ...) { fun(x, ...) } 6.4.2 Resultados Todas as funções retornam algo: return() é usado para definir o resultado explicitamente, e encerrar a execução da função Útil em conjunto com if &amp; else caso contrário, a função retorna o valor de sua última linha invisible() pode ser usado para retornar um valor sem imprimi-lo (a &lt;- 2) #&gt; [1] 2 6.4.3 Exit Handlers Você pode incluir avisos de erros em suas funções: stop(&quot;Erro: x deve ser numérico&quot;) stopifnot(is.numeric(x)) Podemos usar a função on.exit() para rodar uma expressão quando uma função finalizar, independente do motivo 6.4.4 Pacotes Um package é um conjunto de funções com um tema/objetivo específico. Eles contém uma documentação explicativa e as vezes datasets para exemplos O CRAN armazena pacotes que passam testes específicos, mas qualquer um pode criar e postar um pacote no GitHub. Vide install.packages() e o pacote “devtools” Após instalar, para carregar as funções do pacote na lista de ambientes, use library(pkg_name) Para aprender como criar seu próprio pacote, vide este tutorial do MIT e o livro R Packages, 2nd Edition, também de Hadley Wickham O R base conta com 7 pacotes built-in: “base” (a fundação do R, que inicia todos os outros pacotes) “graphics” e “grDevices” (funções gráficas) “utils” (funções utilitárias) “methods” (funções para OOP) “datasets” (bases de dados para treino) “stats” (funções estatísticas) Aprender sobre algumas das funções built-in mais comuns ficará de exercício Complemento Recapitulando Sintaxe (de criação) Componentes (argumentos, corpo, e ambiente) Exceção: funções primitivas Funções no R são first-class e closures Formas: prefix, infix, replacement, e special Combinação: nesting, objetos intermediários, e piping Outros: funções anônimas, do.call(), recursividade, e argumentos padrão São “listas nomeadas” onde as funções buscarão pelas variáveis Além de salvar o ambiente em que foram criadas, funções criam um ambiente filho para serem executadas Base \\(\\leftarrow\\) Pacotes \\(\\leftarrow\\) Global \\(\\leftarrow\\) Função (temporário) Name masking: nomes na função tem prioridade, inclusive funções Início do zero: um novo ambiente vazio é criado a cada chamada Dynamic lookup: os valores são buscados na hora da chamada Lazy evaluation: os argumentos só são avaliados quando acessados Promessas (expressão, ambiente, e valor) OOP: Classes, objetos, e métodos S3, R6, e S4 Polimorfismo e funções genéricas Conceitos adicionais: Dot dot dot Resultados Exit handlers Pacotes Criação: function() e \\() Componentes: formals(), body(), e environment() do.call() Pipes: |&gt; e %&gt;% Resultados: return() e invisible() Exit handlers: stop(), stopifnot(), e on.exit() OOP: UseMethod(). Extra: use sloop::s3_get_method() para obter código fonte de métodos Pacotes: install.packages() e library(). Extra: vide require() Exercícios Dicionário de Funções Referências "],["paradigms.html", "Capítulo 7 Paradigmas de Programação 7.1 Programação Funcional 7.2 Programação Orientada ao Objeto 7.3 Metaprogramação Complemento", " Capítulo 7 Paradigmas de Programação este capítulo está em construção. O que segue abaixo é apenas um rascunho. 7.1 Programação Funcional Apresentação das ideias gerais da programação funcional. O grosso da aplicação será deixada para a segunda parte do livro, durante a explicação do pacote purrr. A referência base são os capítulos 9, 10, e 11, do “Advanced R”. 7.2 Programação Orientada ao Objeto OOP centra a maneira de resolver problemas em objetos métodos para os manipular O R é uma linguagem funcional (orientada à funções), mas tem pacotes que incluem funcionalidades de OOP 7.2.0.1 Definição OOP no R é bem diferente de em outras linguagens mas a ideia básica é a mesma: Cada objeto tem uma classe class (o atributo) Cada classe tem methods “funções” que se aplicam a uma classe específica Classes podem ser criadas com base em outras, herdando os métodos de sua “classe pai” 7.2.1 Sistemas de OOP No R, existem três sistemas principais: S3, o primeiro, usado no R base. É bastante flexível mas pouco rigoroso R6, que estende a característica modify-in-place dos ambientes para outros tipos de objetos S4, uma versão mais rigorosa do S3, útil para grandes projetos Neste curso, vamos falar apenas sobre o sistema S3 7.2.2 Polimorfismo A principal aplicação de OOP no R é o uso de polimorfismo, funções assumirem diferentes formas dependendo da classe de seu (primeiro) argumento: x &lt;- sample(1:10, 20, TRUE) summary(as.numeric(x)) # Min. 1st Qu. Median Mean 3rd Qu. Max. # 1.00 3.75 6.50 6.10 9.00 10.00 summary(as.factor(x)) # 1 3 4 5 6 7 8 9 10 # 2 3 1 1 3 3 1 5 1 Chamamos essas funções de funções genéricas/generics 7.2.3 Funções genéricas Funções genéricas são um intermediário. Elas observam a classe do argumento passado, descobrem qual é o método correto a ser executado: Chamamos a função (genérica) – fun_name(x) A função usa procura o método correto com base na classe de x – UseMethod(&quot;fun_name&quot;) O nome desse processo é method dispatch É encontrado o método, uma “função filho” – fun_name.class_of_x(x) Todas as funções genéricas tem um método default fun_name.default(), caso não exista um método para uma classe específica Intuitivamente, é similar usar um if else: fun_name.factor &lt;- function(x) ... fun_name.numeric &lt;- function(x) ... fun_name.default &lt;- function(x) ... fun_name &lt;- function(x) { if(is.factor(x)) { fun_name.factor(x) } else if(is.numeric(x)) { fun_name.numeric(x) } else { fun_name.default(x) } } A diferença é flexibilidade. Qualquer um pode criar uma classe e adicionar um método à uma função genérica, sem precisar alterar o “código base” da função 7.3 Metaprogramação Apresentação das ideias gerais da metaprogramação. especialmente sobre as bases do tidyverse. A referência base são os capítulos 17, 18, 19, e 20, do “Advanced R”. Apresento o pacote “rlang”. Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["others1.html", "Capítulo 8 Outros Tópicos 8.1 Projetos, Github, e Addins 8.2 Debbuging 8.3 Gerenciamento de Memória e Performance 8.4 Organização de Código e Boas Práticas Complemento", " Capítulo 8 Outros Tópicos Aviso: este capítulo está em construção. O que segue abaixo é apenas um rascunho. 8.1 Projetos, Github, e Addins Existem muitas ferramentas que facilitam a vida do programador. Aqui ensinarei sobre como organizar seus, bem, projetos, com os “Projetos” do RStudio. Darei uma introdução ao controle de versão com Git e sua integração com o RStudio, uma ferramenta que mais programadores deveriam utilizar. E por fim, algumas extensões de “qualidade de vida” disponíveis para o RStudio. 8.2 Debbuging Um dos maiores benefícios da abordagem da primeira parte do livro é entender melhor as causas dos erros. Aqui, mostrarei como esse conhecimento pode ser aplicado, utilizando as ferramentas de debugging do RStudio. 8.3 Gerenciamento de Memória e Performance Um tema mais avançado, para aqueles que precisam fazer códigos eficientes, é como o R gerencia a memória. Darei dicas objetivas para otimizar seu código. 8.4 Organização de Código e Boas Práticas Escrever códigos de maneira limpa e estética é importante, para evitar erros e deixá-los entendíveis. Falarei sobre estilos de código, principalmente o estilo tidyverse, bem como alguns pacotes que ajudam o programador, lintr, e styler. Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["recapitulando-7.html", "Recapitulando Complemento", " Recapitulando este capítulo está em construção. O que segue abaixo é apenas um rascunho. Aqui, apresentarei o recapitulando da primeira parte, falando dos principais aprendizados sobre como o R funciona, e também relembrando os conceitos aprendidos. Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["parte-ii---ciência-de-dados-com-o-tidyverse-1.html", "Parte II - Ciência de Dados com o Tidyverse", " Parte II - Ciência de Dados com o Tidyverse este capítulo está em construção. O que segue abaixo é apenas um rascunho. Bem vindo à segunda parte deste livro. Aqui, foco em ensinar sobre duas das tarefas mais comuns em aplicações do R, manipulação e visualização de dados. Porém, ensino esses conceitas com base na “teoria” por trás de projetos de ciência de dados. Começo explicando como funcionam projetos de ciência de dados, muito com base em (Hadley Wickham 2024). A seguir, apresento o tidyverse, que é um frameworks para manipulação e visualização de dados. Escolhi falar sobre ele, em oposição à usar o R base, ou outro framework, porque ele é um dos agregados de pacotes mais bem trabalhados, com uma sintaxe simples de entender, e que abrange todas as etapas da manipulação de dados. Especialmente, os conceitos expostos na parte I farão com que sua compreensão seja muito mais simples. Aqui, a documentação oficial (“Tidyverse,” n.d.) também é muito usada. Nessa segunda parte, começo a utilizar mais exemplos, uma vez que manipular dados é uma tarefa bastante aplicada. Ainda assim, não tantos quanto outros livros, e as considerações gerais sobre o estilo do presente material se mantem. Os capítulos estão organizados por etapas de um projeto, e pacotes do tidyverse: Capítulo 9: descrevo os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”. Capítulo 11: descrevo os fundamentos e operações da manipulação de dados. Falo como aplicá-las usando os pacotes “dplyr” e “tidyr”. Capítulo 12: descrevo os fundamentos da visualização de dados. Falo como aplicá-la usando o pacote “ggplot2”. Capítulo 13: falo mais sobre strings e factors no R. Apresento as ferramentas de manipulação nos pacotes “stringr”, “forecats”, e “glue”. Capítulo 14: falo sobre as aplicações da programação funcional com o pacote “purrr”. Capítulo 15: falo sobre manipulação de datas e séries de tempo com o pacote “lubridate”, e (pacote a definir). Recapitulado: seção para retomar os conteúdos aprendidos. Referências "],["ds-import.html", "Capítulo 9 Ciência de Dados e Importação 9.1 Ciência de Dados", " Capítulo 9 Ciência de Dados e Importação este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, descreverei os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”. 9.1 Ciência de Dados 9.1.1 Introdução Ciência de Dados: “a aplicação de métodos estatísticos e computacionais para a análise de dados”. Um projeto de ciência de dados normalmente segue o seguinte fluxo: 9.1.2 Preparar Importar os dados: o passo inicial de qualquer projeto de ciência de dados. É necessário saber o tipo de arquivo, o tipo da fonte (arquivos, databases, API’s), e as ferramentas de importação disponíveis. Arrumar (tidy) os dados: limpar e organizar os dados de acordo com o formato necessário. Em D.S., muitas vezes queremos o formato “tidy”, onde cada coluna representa uma variável e cada linha uma observação. Transformar os dados: refinar seus dados para facilitar a uma visualização ou modelagem específica. Este passo envolve reduzir observações, criar novas variáveis e calcular estatísticas resumo. Esses três passo juntos são referidos como data wrangling (“preparação” de dados). 9.1.3 Entender e Explorar Visualização: explorar os dados de maneiras mais interessantes visualmente. Boas visualizações podem revelar mais informação sobre o problema, levantar questões para se atentar, e demandas por mais dados e/ou outros modelos. Modelagem: modelos são ferramentas para responder perguntas sobre o processo gerador dos dados. Eles são conjuntos de hipóteses sobre o problema em mãos, acompanhados por um método computacional para sua estimação. Cada modelo tem seu conjunto de hipóteses, e seus métodos de estimação. Transformar os dados: após entender melhor as demandas do problema, é comum voltar ao passo de transformação dos dados, e repetir o ciclo, até que toda a informação quista seja obtida. 9.1.4 Communicating and Executing Comunicação: após o problema ser analisado, é preciso reportar os resultados Communication: Communication is integral to any data analysis project. It involves conveying your findings to others effectively. No matter how insightful your models or visualizations are, their value is limited if you cannot communicate results in a clear and understandable manner. Programming: Programming is a pervasive tool in data science. While not mandatory to be an expert programmer, improving programming skills aids in automating tasks and tackling new challenges efficiently. Programming is a cross-cutting skill used throughout the entire data science project. "],["data.html", "Capítulo 10 Data 10.1 Types of Data 10.2 Importing with readr 10.3 Data Visualization Complemento", " Capítulo 10 Data 10.1 Types of Data 10.2 Importing with readr 10.3 Data Visualization Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["manipulation.html", "Capítulo 11 Manipulação de Dados 11.1 Operações de Manipulação Complemento", " Capítulo 11 Manipulação de Dados este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, descreverei os fundamentos e operações da manipulação de dados. Falo como aplicá-las usando os pacotes “dplyr” e “tidyr”. 11.1 Operações de Manipulação 11.1.1 Operações em Observações 11.1.2 Operações em Variáveis 11.1.3 Operações em Células 11.1.4 Operações em Grupos 11.1.5 Operações de União 11.1.6 Operações de Remodelação Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["visualization.html", "Capítulo 12 Visualização Gráfica 12.1 Introdução à Visualização 12.2 Layers 12.3 Scales 12.4 Grammar 12.5 Others Complemento", " Capítulo 12 Visualização Gráfica este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, descreverei os fundamentos da visualização de dados. Falo como aplicá-la usando o pacote “ggplot2”. 12.1 Introdução à Visualização 12.2 Layers 12.3 Scales 12.4 Grammar 12.5 Others Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["strings-factors.html", "Capítulo 13 Manipulação de Strings e Factors 13.1 Strings 13.2 Factors Complemento", " Capítulo 13 Manipulação de Strings e Factors este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, falarei mais sobre strings e factors no R. Apresento as ferramentas de manipulação nos pacotes “stringr”, “forecats”, e “glue”. 13.1 Strings 13.1.1 Matches 13.1.2 Mutate 13.1.3 Subset 13.1.4 Join and Split 13.1.5 Lengths 13.1.6 Order 13.2 Factors 13.2.1 Inspect 13.2.2 Combine 13.2.3 Reorder 13.2.4 Revalue 13.2.5 Relevel Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["functional.html", "Capítulo 14 Programação Funcional 14.1 Map 14.2 Others Complemento", " Capítulo 14 Programação Funcional este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, falarei sobre as aplicações da programação funcional com o pacote “purrr”. 14.1 Map 14.1.1 Map 1 14.1.2 Map 2 14.1.3 Map p 14.2 Others 14.2.1 Modify 14.2.2 Reduce 14.2.3 Predicates 14.2.4 Pluck 14.2.5 Reshape 14.2.6 Concatenate Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["time-series.html", "Capítulo 15 Manipulação de Datas e Séries de Tempo 15.1 Dates 15.2 Time Series Complemento", " Capítulo 15 Manipulação de Datas e Séries de Tempo este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, falarei sobre manipulação de datas e séries de tempo com o pacote “lubridate”, e (pacote a definir). 15.1 Dates 15.1.1 Parsing 15.1.2 Mutate 15.1.3 Time Zones 15.1.4 Math 15.1.5 Periods, Durations, e Intervals 15.2 Time Series Framework a ser definido Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["recapitulando-15.html", "Recapitulando", " Recapitulando este capítulo está em construção. O que segue abaixo é apenas um rascunho. Aqui, apresentarei o recapitulando da segunda parte, falando dos fundamentos e etapas de projetos de ciência de dados, e como cada ferramenta do tidyverse nos ajuda a aplicá-las. "],["parte-iii---aplicações-diversas.html", "Parte III - Aplicações Diversas", " Parte III - Aplicações Diversas este capítulo está em construção. O que segue abaixo é apenas um rascunho. Bem vindo à terceira parte deste livro. Aqui, o objetivo é mostrar como aplicar os conhecimentos adquiridos nas outras duas partes, em temas comuns. Já existe uma literatura extensa com objetivos similares, portanto, foco em temas mais centrais, e/ou que tenham um alto ganho de serem abordados com os frameworks e linguagem desenvolvida neste livro. Agora sim, o estilo do livro é bem mais mostrar as capacidades do R através de exemplos, do que o estudo teórico das outras seções. Os temas são: Capítulo 16: apresento como resolver problemas comuns em probabilidade e estatística, o assunto central do R. Capítulo 17: apresento como aplicar as habilidades de manipulação e visualização de dados, para explorar e obter informações contidas em datasets. Capítulo 18: apresento como realizar análises de regressões, com base nos vários modelos comuns inclusos no R. Capítulo 19: complementar à regressões, apresento rapidamente alguns frameworks para modelos mais complexos de machine learning. Capítulo 12.5: para servir de referência, listo outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro. "],["stats-prob.html", "Capítulo 16 Probabilidade e Estatística 16.1 Probability 16.2 Statistics Complemento", " Capítulo 16 Probabilidade e Estatística este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, apresentarei como resolver problemas comuns em probabilidade e estatística, o assunto central do R. 16.1 Probability 16.1.1 Random Numbers 16.1.2 Useful Measures 16.2 Statistics 16.2.1 Useful Measures 16.2.2 Hypothesis Testing Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["exploration.html", "Capítulo 17 Exploração de Dados 17.1 Useful Visualizations 17.2 Useful Metrics 17.3 Useful Graphs Complemento", " Capítulo 17 Exploração de Dados este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, apresentarei como aplicar as habilidades de manipulação e visualização de dados, para explorar e obter informações contidas em datasets. 17.1 Useful Visualizations 17.2 Useful Metrics 17.3 Useful Graphs Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["regression.html", "Capítulo 18 Regressão 18.1 Fundamentals 18.2 Linear Models 18.3 Non-Linear Models 18.4 Time-Series Models Complemento", " Capítulo 18 Regressão este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, apresentarei como realizar análises de regressões, com base nos vários modelos comuns inclusos no R. 18.1 Fundamentals 18.1.1 Data 18.1.2 Formulas 18.1.3 Fitting 18.1.4 Visualizing 18.1.5 Testing 18.1.6 Correcting 18.2 Linear Models 18.3 Non-Linear Models 18.4 Time-Series Models Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["ml.html", "Capítulo 19 Aprendizado de Máquina 19.1 Fundamentals 19.2 ML in Built-In R 19.3 ML in External Packages Complemento", " Capítulo 19 Aprendizado de Máquina este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, apresentarei rapidamente alguns frameworks para modelos mais complexos de machine learning. 19.1 Fundamentals 19.2 ML in Built-In R 19.3 ML in External Packages Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["others3.html", "Capítulo 20 Outras Aplicações Complemento", " Capítulo 20 Outras Aplicações Aviso: este capítulo está em construção. O que segue abaixo é apenas um rascunho. Neste capítulo, listarei outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro. Alguns dos temas: Economia e finanças com tidyquant. Modelagem com tidymodels. Comunicação com RMarkdown, stargazer, broom, e Shiny. Otimização. Bioestatística e estatística geoespacial. Pacotes. Complemento Recapitulando Exercícios Dicionário de Funções Referências "],["dict.html", "Dicionário de funções", " Dicionário de funções Abaixo segue a lista de funções vistas neste livro. Capítulo Categoria Função Descrição Uso 1 aritmétrica + soma num + num 1 aritmétrica - subtração num - num 1 aritmétrica * multiplicação num * num 1 aritmétrica / divisão num / num 1 aritmétrica \\^ exponenciação num ^ num 1 aritmétrica %% divisão inteira num %% num 1 aritmétrica %/% resto da divisão num %/% num 1 comparação == igual x == y 1 comparação != diferente x != y 1 comparação &lt; menor que num &lt; num 1 comparação &gt; maior que num &gt; num 1 comparação &gt;= maior igual num &gt;= num 1 comparação &lt;= menor igual num &lt;= num 1 lógica ! “não” lógico ! logi 1 lógica &amp; “e” lógico logi &amp; logi 1 lógica &amp;#124; “ou” lógico logi &amp;#124; logi 1 agrupadores { agrupador chaves { expr } 1 agrupadores ( agrupador parênteses ( expr ) 1 definidores &lt;-, -&gt; definidores x &lt;- expr, x -&gt; expr 1 definidores = definidores x = expr 1 definidores assign() definidores assign(\"x\", expr) 1 outros rm() limpa objetos do ambiente rm(x) 1 nomes make.names() NA NA 1 ajuda help(), ? procurar ajuda na documentação help(x), ?x 1 ajuda vignette() procurar vignettes vignette(x) "],["referências-19.html", "Referências", " Referências Abaixo seguem as principais referências deste livro. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
